 NtCreateThreadEx() NSPA RT hacks

 - set PTHREAD_PRIO_PROTECT mutex attribute for pthreads. 
 
   This is needed to avoid priority inversion. - Which is possible, without
   changing this protocol.
   
 - add thread_data->pthread_id to validSyncThread list, filter unsupported 
   threads. (handle == GetCurrentThread() is unsupported. ie: W32 threads).
 
   this is WIP. but the gist; it allows setting specific threads within wine and
   winelib as RT. By using NtCreateThreadEx(), at pthread creation time; 
   to setup synchronization and other RT threads -- it builds on top of code in 
   the Wine-NSPA RT implementation patch, already being used.
   
   The main process threads in Wine become RT, while their W32 threads do not.
   W32 threads are still managed by set_thread_priority() / their respective
   windows API scheduling priority and prioclass.
   
   This helps avoid starving wine's programs/processes, without messing with
   WINAPI threads/scheduling (which would crash wine anyway).
   
   NOTE: I need to test this with more winelib apps. FSTHost is happy about this
   change, YaBridge also doesn't seem to mind -- but depending, this may cause
   issues with some winelib apps. i don't know... It also may be that I need to
   be a bit smarter with heuristics, but all in good time.
  
 - add NSPA_RTHREAD_INFO debug option.
   
   PROGRAM NAME:
   Pthread Thread Priority:
   Windows Thread ID:
   NtCreateThreadEx => pthread_self()
   NtCreateThreadEx => gettid()
   
   just some basic, but useful info.
   
 - Adjust RT priorities and placement;
 
   1). Stop subtraction (-1) of priorities in Wine-NSPA
   2). Decrement priority by 2 (-2) consistenetly.
   3). Make room in get_unix_priority() for Sync threads to sit directly below
       THREAD_PRIORITY_TIME_CRITICAL threads
    
 Hopefully, I can enable this soon - but It's going to require more testing. So 
 far, it's working very well for me. However, this is a rather large change - as
 it fundementally changes Wine's threading... It's unchartered territory.
 
 NOTE: this patch requires a newish version of glibc for it's debug stuff. In 
 the final version, I will either split out the debug into a separate patch OR
 I will add a macro, so it's only built if system requirements are met.
 
 johnstonlordan <AT> gmail <DOT> comm
 
diff -pur a/dlls/ntdll/thread.c b/dlls/ntdll/thread.c
--- a/dlls/ntdll/thread.c	2020-07-11 00:34:31.151780000 -0400
+++ b/dlls/ntdll/thread.c	2020-07-11 10:50:15.895457585 -0400
@@ -23,6 +23,7 @@
 
 #include <assert.h>
 #include <stdarg.h>
+#include <unistd.h>
 #include <string.h>
 #include <stdio.h>
 #include <limits.h>
@@ -97,7 +98,7 @@ int ntdll_set_sync_realtime (pthread_t p
         thread_apc_priority = apc_priority;
     }
 	struct sched_param param;	
-	param.sched_priority = thread_apc_priority -1;
+	param.sched_priority = thread_apc_priority -2;
 
 	return pthread_setschedparam (pthread_id, wine_rt_policy, &param);
 }
@@ -642,6 +643,12 @@ NTSTATUS WINAPI NtCreateThreadEx( HANDLE
     int wine_rt_policy = 0;
     pthread_attr_setschedpolicy (&pthread_attr, wine_rt_policy);
     pthread_attr_setschedparam (&pthread_attr, &parm);
+    pthread_mutexattr_t mattr;
+    pthread_mutexattr_setprotocol(&mattr, PTHREAD_PRIO_PROTECT);
+    // glibc get the program name
+    extern char *__progname;
+    // Add runtime option for checking thread info.
+    const char *threadInfo = getenv("NSPA_THREAD_INFO");
 #endif
     BOOLEAN suspended = !!(flags & THREAD_CREATE_FLAGS_CREATE_SUSPENDED);
     CLIENT_ID *id = NULL;
@@ -780,7 +787,11 @@ NTSTATUS WINAPI NtCreateThreadEx( HANDLE
     thread_data->esync_queue_fd = 0;
     thread_data->esync_apc_fd = 0;
     thread_data->fsync_apc_idx = 0;
-
+#if NSPA_RT_SYNC
+    thread_data->pthread_id  =  0;
+#endif
+    
+    pthread_mutexattr_init ( &mattr );
     pthread_attr_init( &pthread_attr );
     pthread_attr_setstack( &pthread_attr, teb->DeallocationStack,
                          (char *)teb->Tib.StackBase + extra_stack - (char *)teb->DeallocationStack );
@@ -807,25 +818,55 @@ NTSTATUS WINAPI NtCreateThreadEx( HANDLE
     // 
     // Catch all Synchronization Threads;
     pthread_t validSyncThread = (thread_data->fsync_apc_idx || thread_data->esync_apc_fd ||
-                                 thread_data->esync_queue_fd);
+                                 thread_data->esync_queue_fd || thread_data->pthread_id);
     if (validSyncThread == 0) {
         int i;
         for (i = 0; i < 100; ++i) {
             validSyncThread = (thread_data->fsync_apc_idx || thread_data->esync_apc_fd ||
-                               thread_data->esync_queue_fd);
+                               thread_data->esync_queue_fd || thread_data->pthread_id);
             if (validSyncThread == 0)
-                usleep(100);
+                usleep(300);
         }
     }
     if (validSyncThread != 0) {
-        // this may be redundant, but set PTHREAD_EXPLICIT_SCHED for the
-        // esync/fsync kernel-mode APC threads.
-        pthread_attr_setinheritsched(&pthread_attr, PTHREAD_EXPLICIT_SCHED);
+        // Fail on / filter out unsupported threads;
+        if (handle == GetCurrentThread() && (validSyncThread != thread_data->fsync_apc_idx || 
+            thread_data->esync_apc_fd || thread_data->esync_queue_fd)) {
+            //  if getenv("NSPA_THREAD_INFO") is set.
+            if (threadInfo) {
+                fprintf(stderr, "==> PROGRAM NAME: %s <==\n", __progname);
+                fprintf(stderr, "Windows Thread ID: %d\n", GetCurrentThreadId());
+                fprintf(stderr, "Invalid Thread => GetCurrentThread(): %p\n", GetCurrentThread());
+            }
+            return status;
+        }
+
         // set RT for sync threads
-    	ntdll_set_sync_realtime(validSyncThread, wine_rt_policy, priority);
-    	}
-    else
-        WARN("no RT sync for thread\n");
+        pthread_attr_setinheritsched(&pthread_attr, PTHREAD_EXPLICIT_SCHED);
+        ntdll_set_sync_realtime(pthread_self(), wine_rt_policy, priority);
+    	
+        //  if getenv("NSPA_THREAD_INFO") is set.	
+        if (threadInfo) {
+            struct sched_param param;
+            // if sched_getparam() returns zero, lets go;
+            if (sched_getparam( gettid(), &param ) == 0) {
+    	    
+            // Get the current thread priority
+            sched_getparam(0, &param);
+    	    
+            // note: policy isn't of interest here. it's FIFO or RR.
+            // if 0 is returned - it's SCHED_OTHER.
+    	    
+            // Thread / Process Info.
+            fprintf(stderr, "--------------------------------------------\n");
+            fprintf(stderr, "==> PROGRAM NAME: %s <==\n", __progname);
+            fprintf(stderr, "Pthread Thread Priority: %d\n", param.sched_priority);
+            fprintf(stderr, "Windows Thread ID: %d\n", GetCurrentThreadId());
+            fprintf(stderr, "NtCreateThreadEx => pthread_self(): %ld\n", pthread_self());
+            fprintf(stderr, "NtCreateThreadEx => glibc gettid(): %d\n", gettid());
+            }
+        }
+    }
 #endif
 
     return STATUS_SUCCESS;
diff -pur a/server/scheduler.c b/server/scheduler.c
--- a/server/scheduler.c	2020-07-11 00:34:31.152780000 -0400
+++ b/server/scheduler.c	2020-07-10 23:54:19.399427000 -0400
@@ -86,7 +86,7 @@ void init_scheduler( void )
     } 
 
     /* change the wineserver priority */
-    if ((priority = get_priority( "WINE_RT_PRIO", min, max -1)) != -1)
+    if ((priority = get_priority( "WINE_RT_PRIO", min, max)) != -1)
     {       
         struct sched_param param;
         memset( &param, 0, sizeof(param) );
@@ -154,13 +154,13 @@ void set_scheduler_priority( struct thre
     if ((thread->priority = PROCESS_PRIOCLASS_REALTIME) && (thread->priority != THREAD_PRIORITY_TIME_CRITICAL ||
          THREAD_PRIORITY_NORMAL || THREAD_PRIORITY_BELOW_NORMAL || THREAD_PRIORITY_IDLE ))
     {
-        param.sched_priority = thread_base_priority -1;
+        param.sched_priority = thread_base_priority;
     }
     // Hardcoded to SCHED_FIFO just for TIME_CRITICAL threads.
     if ((thread->priority = PROCESS_PRIOCLASS_REALTIME && THREAD_PRIORITY_TIME_CRITICAL ))
     {
         wine_rt_policy = SCHED_FIFO;
-        param.sched_priority = thread_base_priority -1;
+        param.sched_priority = thread_base_priority;
     } 
     else
     {
diff -pur a/server/thread.c b/server/thread.c
--- a/server/thread.c	2020-07-11 00:34:31.153780000 -0400
+++ b/server/thread.c	2020-07-11 10:49:41.189190050 -0400
@@ -749,7 +749,7 @@ static int get_unix_priority( int priori
     // RT priority for threads must be below kernel-mode APC, TIME_CRITICAL threads and Wineserver.
     if ((base_priority = get_priority( "WINE_RT_PRIO", min, max )) != -1)
     {
-        thread_base_priority = base_priority - 1;
+        thread_base_priority = base_priority;
     }
            
     // SCHED_FIFO/SCHED_RR:
@@ -835,12 +835,12 @@ static int get_unix_priority( int priori
         case THREAD_PRIORITY_LOWEST: return 0;
         case THREAD_PRIORITY_BELOW_NORMAL: return 0;
         case THREAD_PRIORITY_NORMAL: return 0;
-        case THREAD_PRIORITY_ABOVE_NORMAL: return -4 + thread_base_priority;
-        case THREAD_PRIORITY_HIGHEST: return -3 + thread_base_priority;
-        case 3: return -2 + thread_base_priority;
-        case 4: return -2 + thread_base_priority;
-        case 5: return -2 + thread_base_priority;
-        case 6: return -2 + thread_base_priority;  
+        case THREAD_PRIORITY_ABOVE_NORMAL: return -8 + thread_base_priority;
+        case THREAD_PRIORITY_HIGHEST: return -6 + thread_base_priority;
+        case 3: return -4 + thread_base_priority;
+        case 4: return -4 + thread_base_priority;
+        case 5: return -4 + thread_base_priority;
+        case 6: return -4 + thread_base_priority;  
         case THREAD_PRIORITY_TIME_CRITICAL: return thread_base_priority;
         }
     }
