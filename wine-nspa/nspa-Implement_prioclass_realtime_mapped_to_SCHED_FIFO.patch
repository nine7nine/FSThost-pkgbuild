This patch is based on Rémi Bernon's patch implementing Windows PrioClasses and 
mapping them to unix... It also is based on the wine RT patch that lives in 
Wine-Staging. -- because of that;

   0001-wineserver-Draft-to-implement-priority-levels-throug.patch
   
...must be reverted, before applying.

The RT patch in staging can't actually setup PROCESS_PRIOCLASS_REALTIME threads
correctly. It's very rudimentary and misses 80% of threads that desperately 
want to be RT/FIFO in Wine (for audio use, anway).

Likewise, Rémi's patch doesn't with setting the threads up how I want them - but
it does expose the prioclasses / mappings. ~ So I've modified PROCESS_PRIOCLASS_REALTIME
cases, so that each case returns exactly what i want for SCHED_FIFO threads.

NOTE: This is WIP / unfinished, but IS working.

 <johnstonljordan AT gmail.com>

diff -pur a/configure b/configure
--- a/configure	2020-06-14 00:22:49.378578000 -0400
+++ b/configure	2020-06-10 18:02:25.008635000 -0400
@@ -13890,9 +13890,14 @@ $as_echo "$as_me:${as_lineno-$LINENO}: d
 $as_echo "$as_me:${as_lineno-$LINENO}: dbus-1 libs: $DBUS_LIBS" >&5
 ac_save_CPPFLAGS=$CPPFLAGS
 CPPFLAGS="$CPPFLAGS $DBUS_CFLAGS"
-ac_fn_c_check_header_mongrel "$LINENO" "dbus/dbus.h" "ac_cv_header_dbus_dbus_h" "$ac_includes_default"
+for ac_header in dbus/dbus.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "dbus/dbus.h" "ac_cv_header_dbus_dbus_h" "$ac_includes_default"
 if test "x$ac_cv_header_dbus_dbus_h" = xyes; then :
-  { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -ldbus-1" >&5
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_DBUS_DBUS_H 1
+_ACEOF
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -ldbus-1" >&5
 $as_echo_n "checking for -ldbus-1... " >&6; }
 if ${ac_cv_lib_soname_dbus_1+:} false; then :
   $as_echo_n "(cached) " >&6
@@ -13951,6 +13956,7 @@ else
   DBUS_CFLAGS=""
 fi
 
+done
 
 CPPFLAGS=$ac_save_CPPFLAGS
 test -z "$DBUS_CFLAGS" || DBUS_CFLAGS=`echo " $DBUS_CFLAGS" | sed 's/ -I\([^/]\)/ -I\$(top_builddir)\/\1/g'`
@@ -19389,6 +19395,75 @@ $as_echo "#define HAVE_SCHED_SETAFFINITY
 
 fi
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for sched_setscheduler" >&5
+$as_echo_n "checking for sched_setscheduler... " >&6; }
+if ${wine_cv_have_sched_setscheduler+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#define _GNU_SOURCE
+#include <sched.h>
+int
+main ()
+{
+sched_setscheduler(0, 0, 0);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  wine_cv_have_sched_setscheduler=yes
+else
+  wine_cv_have_sched_setscheduler=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $wine_cv_have_sched_setscheduler" >&5
+$as_echo "$wine_cv_have_sched_setscheduler" >&6; }
+if test "$wine_cv_have_sched_setscheduler" = "yes"
+then
+
+$as_echo "#define HAVE_SCHED_SETSCHEDULER 1" >>confdefs.h
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for setpriority" >&5
+$as_echo_n "checking for setpriority... " >&6; }
+if ${wine_cv_have_setpriority+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#define _GNU_SOURCE
+#include <sys/resource.h>
+#include <sys/time.h>
+int
+main ()
+{
+setpriority(0, 0, 0);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  wine_cv_have_setpriority=yes
+else
+  wine_cv_have_setpriority=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $wine_cv_have_setpriority" >&5
+$as_echo "$wine_cv_have_setpriority" >&6; }
+if test "$wine_cv_have_setpriority" = "yes"
+then
+
+$as_echo "#define HAVE_SETPRIORITY 1" >>confdefs.h
+
+fi
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for fallocate" >&5
 $as_echo_n "checking for fallocate... " >&6; }
 if ${wine_cv_have_fallocate+:} false; then :
diff -pur a/configure.ac b/configure.ac
--- a/configure.ac	2020-06-14 00:22:49.380578000 -0400
+++ b/configure.ac	2020-06-10 18:02:25.008635000 -0400
@@ -1485,7 +1485,7 @@ dnl **** Check for libdbus ****
 if test "x$with_dbus" != "xno"
 then
     WINE_PACKAGE_FLAGS(DBUS,[dbus-1],,,,
-        [AC_CHECK_HEADER([dbus/dbus.h],
+        [AC_CHECK_HEADERS([dbus/dbus.h],
             [WINE_CHECK_SONAME(dbus-1, dbus_connection_close,,[DBUS_CFLAGS=""],[$DBUS_LIBS])],
             [DBUS_CFLAGS=""])])
 fi
@@ -2405,6 +2405,25 @@ then
   AC_DEFINE(HAVE_SCHED_SETAFFINITY, 1, [Define to 1 if you have the `sched_setaffinity' function.])
 fi
 
+AC_CACHE_CHECK([for sched_setscheduler],wine_cv_have_sched_setscheduler,
+                AC_LINK_IFELSE([AC_LANG_PROGRAM(
+[[#define _GNU_SOURCE
+#include <sched.h>]], [[sched_setscheduler(0, 0, 0);]])],[wine_cv_have_sched_setscheduler=yes],[wine_cv_have_sched_setscheduler=no]))
+if test "$wine_cv_have_sched_setscheduler" = "yes"
+then
+  AC_DEFINE(HAVE_SCHED_SETSCHEDULER, 1, [Define to 1 if you have the `sched_setscheduler' function.])
+fi
+
+AC_CACHE_CHECK([for setpriority],wine_cv_have_setpriority,
+                AC_LINK_IFELSE([AC_LANG_PROGRAM(
+[[#define _GNU_SOURCE
+#include <sys/resource.h>
+#include <sys/time.h>]], [[setpriority(0, 0, 0);]])],[wine_cv_have_setpriority=yes],[wine_cv_have_setpriority=no]))
+if test "$wine_cv_have_setpriority" = "yes"
+then
+  AC_DEFINE(HAVE_SETPRIORITY, 1, [Define to 1 if you have the `setpriority' function.])
+fi
+
 AC_CACHE_CHECK([for fallocate],wine_cv_have_fallocate,
                 AC_LINK_IFELSE([AC_LANG_PROGRAM(
 [[#define _GNU_SOURCE
diff -pur a/include/config.h.in b/include/config.h.in
--- a/include/config.h.in	2020-06-14 00:22:49.212589000 -0400
+++ b/include/config.h.in	2020-06-10 18:02:25.009635000 -0400
@@ -100,6 +100,9 @@
 /* Define to 1 if you have the <curses.h> header file. */
 #undef HAVE_CURSES_H
 
+/* Define to 1 if you have the <dbus/dbus.h> header file. */
+#undef HAVE_DBUS_DBUS_H
+
 /* Define to 1 if you have the <dirent.h> header file. */
 #undef HAVE_DIRENT_H
 
@@ -806,6 +809,9 @@
 /* Define to 1 if you have the `sched_setaffinity' function. */
 #undef HAVE_SCHED_SETAFFINITY
 
+/* Define to 1 if you have the `sched_setscheduler' function. */
+#undef HAVE_SCHED_SETSCHEDULER
+
 /* Define to 1 if you have the `sched_yield' function. */
 #undef HAVE_SCHED_YIELD
 
@@ -830,6 +836,9 @@
 /* Define to 1 if you have the `select' function. */
 #undef HAVE_SELECT
 
+/* Define to 1 if you have the `setpriority' function. */
+#undef HAVE_SETPRIORITY
+
 /* Define to 1 if you have the `setproctitle' function. */
 #undef HAVE_SETPROCTITLE
 
diff -pur a/server/main.c b/server/main.c
--- a/server/main.c	2020-06-14 00:22:49.449573000 -0400
+++ b/server/main.c	2020-06-11 18:16:22.112084663 -0400
@@ -150,6 +150,7 @@ int main( int argc, char *argv[] )
 
     if (debug_level) fprintf( stderr, "wineserver: starting (pid=%ld)\n", (long) getpid() );
     set_current_time();
+    init_scheduler();
     init_signals();
     init_directories();
     init_registry();
diff -pur a/server/Makefile.in b/server/Makefile.in
--- a/server/Makefile.in	2020-06-14 00:22:49.449573000 -0400
+++ b/server/Makefile.in	2020-06-11 18:16:22.111084653 -0400
@@ -32,6 +32,7 @@ C_SRCS = \
 	region.c \
 	registry.c \
 	request.c \
+	scheduler.c \
 	semaphore.c \
 	serial.c \
 	signal.c \
@@ -52,4 +53,5 @@ MANPAGES = \
 	wineserver.fr.UTF-8.man.in \
 	wineserver.man.in
 
-EXTRALIBS = $(LDEXECFLAGS) $(POLL_LIBS) $(RT_LIBS) $(INOTIFY_LIBS)
+EXTRAINCL = $(DBUS_CFLAGS)
+EXTRALIBS = $(LDEXECFLAGS) $(POLL_LIBS) $(RT_LIBS) $(INOTIFY_LIBS) $(DBUS_LIBS)
diff -pur a/server/thread.c b/server/thread.c
--- a/server/thread.c	2020-06-14 00:22:49.450573000 -0400
+++ b/server/thread.c	2020-06-16 17:48:49.215010352 -0400
@@ -38,6 +38,12 @@
 #ifdef HAVE_SCHED_H
 #include <sched.h>
 #endif
+#ifdef HAVE_SYS_TIME_H
+#include <sys/time.h>
+#endif
+#ifdef HAVE_SYS_RESOURCE_H
+#include <sys/resource.h>
+#endif
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -54,6 +60,145 @@
 #include "esync.h"
 #include "fsync.h"
 
+static int thread_base_priority = -1;
+
+/* gets the priority value from an environment variable */
+static int get_priority( const char *variable, int min, int max )
+{
+    const char *env;
+    int val;
+
+    env = getenv( variable );
+    if (!env) return -1;
+
+    val = atoi( env );
+    if (val >= min && val <= max) return val;
+    fprintf( stderr, "wineserver: %s should be between %d and %d\n", variable, min, max );
+    return -1;
+}
+
+#ifdef HAVE_DBUS_DBUS_H
+#include <dbus/dbus.h>
+
+static int dbus_error_to_errno( DBusError* err )
+{
+    if (!err)
+        return EINVAL;
+    if (strcmp(err->name, DBUS_ERROR_NO_MEMORY) == 0)
+        return ENOMEM;
+    if (strcmp(err->name, DBUS_ERROR_SERVICE_UNKNOWN) == 0 ||
+        strcmp(err->name, DBUS_ERROR_NAME_HAS_NO_OWNER) == 0)
+        return ENOENT;
+    if (strcmp(err->name, DBUS_ERROR_ACCESS_DENIED) == 0 ||
+        strcmp(err->name, DBUS_ERROR_AUTH_FAILED) == 0)
+        return EACCES;
+    return EIO;
+}
+
+static int rtkit_set_realtime( dbus_uint64_t process, dbus_uint64_t thread, dbus_uint32_t priority )
+{
+    DBusConnection* dbus = NULL;
+    DBusMessage *msg = NULL, *rep = NULL;
+    DBusError err;
+    int ret = -1;
+
+    dbus_error_init(&err);
+
+    dbus = dbus_bus_get_private(DBUS_BUS_SYSTEM, &err);
+    if (dbus_error_is_set(&err))
+        goto error;
+
+    dbus_connection_set_exit_on_disconnect(dbus, 0);
+
+    if (!(msg = dbus_message_new_method_call("org.freedesktop.RealtimeKit1",
+                                            "/org/freedesktop/RealtimeKit1",
+                                            "org.freedesktop.RealtimeKit1",
+                                            "MakeThreadRealtimeWithPID")))
+        goto error;
+
+    if (!dbus_message_append_args(msg,
+                                  DBUS_TYPE_UINT64, &process,
+                                  DBUS_TYPE_UINT64, &thread,
+                                  DBUS_TYPE_UINT32, &priority,
+                                  DBUS_TYPE_INVALID))
+        goto error;
+
+    if (!(rep = dbus_connection_send_with_reply_and_block(dbus, msg, -1, &err)))
+        goto error;
+
+    if (dbus_error_is_set(&err))
+        goto error;
+
+    if (dbus_set_error_from_message(&err, rep))
+        goto error;
+
+    ret = 0;
+
+error:
+    if (ret) errno = dbus_error_to_errno(&err);
+    if (rep) dbus_message_unref(rep);
+    if (msg) dbus_message_unref(msg);
+    if (dbus)
+    {
+        dbus_connection_close(dbus);
+        dbus_connection_unref(dbus);
+    }
+    dbus_error_free(&err);
+    return ret;
+}
+
+static int rtkit_set_niceness( dbus_uint64_t process, dbus_uint64_t thread, dbus_int32_t niceness )
+{
+    DBusConnection* dbus = NULL;
+    DBusMessage *msg = NULL, *rep = NULL;
+    DBusError err;
+    int ret = -1;
+
+    dbus_error_init(&err);
+
+    dbus = dbus_bus_get_private(DBUS_BUS_SYSTEM, &err);
+    if (dbus_error_is_set(&err))
+        goto error;
+
+    dbus_connection_set_exit_on_disconnect(dbus, 0);
+
+    if (!(msg = dbus_message_new_method_call("org.freedesktop.RealtimeKit1",
+                                            "/org/freedesktop/RealtimeKit1",
+                                            "org.freedesktop.RealtimeKit1",
+                                            "MakeThreadHighPriorityWithPID")))
+        goto error;
+
+    if (!dbus_message_append_args(msg,
+                                  DBUS_TYPE_UINT64, &process,
+                                  DBUS_TYPE_UINT64, &thread,
+                                  DBUS_TYPE_INT32, &niceness,
+                                  DBUS_TYPE_INVALID))
+        goto error;
+
+    if (!(rep = dbus_connection_send_with_reply_and_block(dbus, msg, -1, &err)))
+        goto error;
+
+    if (dbus_error_is_set(&err))
+        goto error;
+
+    if (dbus_set_error_from_message(&err, rep))
+        goto error;
+
+    ret = 0;
+
+error:
+    if (ret) errno = dbus_error_to_errno(&err);
+    if (rep) dbus_message_unref(rep);
+    if (msg) dbus_message_unref(msg);
+    if (dbus)
+    {
+        dbus_connection_close(dbus);
+        dbus_connection_unref(dbus);
+    }
+    dbus_error_free(&err);
+    return ret;
+}
+#endif
 
 #ifdef __i386__
 static const unsigned int supported_cpus = CPU_FLAG(CPU_x86);
@@ -642,28 +787,213 @@ affinity_t get_thread_affinity( struct t
     return mask;
 }
 
+#if defined(HAVE_SCHED_SETSCHEDULER) || defined(HAVE_SETPRIORITY) || \
+    defined(HAVE_DBUS_DBUS_H)
+static int get_unix_priority( int priority_class, int priority )
+{
+    int min, max, base_priority;
+
+    min = sched_get_priority_min( SCHED_FIFO );
+    max = sched_get_priority_max( SCHED_FIFO );
+
+    // RT priority for threads must be below APC futex and Wineserver.(ref: min, max -4)
+    if ((base_priority = get_priority( "WINE_RT_PRIO", min, max - 4 )) != -1)
+    {
+        thread_base_priority = base_priority;
+    }
+           
+    // SCHED_FIFO:
+    //
+    // We don't care about anything except for PROCESS_PRIOCLASS_REALTIME. Setting other 
+    // threads RT will only munge/chew the threading in apps.
+    //  
+    // SCHED_OTHER: 
+    //
+    // We set the thread priority / niceness ( eg: 0, -20 ). the 'thread_base_priority'
+    // must be subtracted, or it returns bogus values.
+    
+    switch (priority_class) {
+    case PROCESS_PRIOCLASS_IDLE:
+        switch (priority) {
+        case THREAD_PRIORITY_IDLE: return 15 + priority - thread_base_priority;
+        case THREAD_PRIORITY_LOWEST: return 10 + priority - thread_base_priority;
+        case THREAD_PRIORITY_BELOW_NORMAL: return 8 + priority - thread_base_priority;
+        case THREAD_PRIORITY_NORMAL: return 6 + priority - thread_base_priority;
+        case THREAD_PRIORITY_ABOVE_NORMAL: return 4 + priority - thread_base_priority;
+        case THREAD_PRIORITY_HIGHEST: return 2 + priority - thread_base_priority;
+        case THREAD_PRIORITY_TIME_CRITICAL: return -15 + priority - thread_base_priority;
+        }
+    case PROCESS_PRIOCLASS_BELOW_NORMAL:
+        switch (priority) {
+        case THREAD_PRIORITY_IDLE: return 15 + priority - thread_base_priority;
+        case THREAD_PRIORITY_LOWEST: return 8 + priority - thread_base_priority;
+        case THREAD_PRIORITY_BELOW_NORMAL: return 6 + priority - thread_base_priority;
+        case THREAD_PRIORITY_NORMAL: return 4 + priority - thread_base_priority;
+        case THREAD_PRIORITY_ABOVE_NORMAL: return 2 + priority - thread_base_priority;
+        case THREAD_PRIORITY_HIGHEST: return 0 + priority - thread_base_priority;
+        case THREAD_PRIORITY_TIME_CRITICAL: return -15 + priority - thread_base_priority;
+        }
+    case PROCESS_PRIOCLASS_NORMAL:
+        switch (priority) {
+        case THREAD_PRIORITY_IDLE: return 15 + priority - thread_base_priority;
+        case THREAD_PRIORITY_LOWEST: return 4 + priority - thread_base_priority;
+        case THREAD_PRIORITY_BELOW_NORMAL: return 2 + priority - thread_base_priority;
+        case THREAD_PRIORITY_NORMAL: return 0 + priority - thread_base_priority;
+        case THREAD_PRIORITY_ABOVE_NORMAL: return -2 + priority - thread_base_priority;
+        case THREAD_PRIORITY_HIGHEST: return -4 + priority - thread_base_priority;
+        case THREAD_PRIORITY_TIME_CRITICAL: return -15 + priority - thread_base_priority;
+        }
+    case PROCESS_PRIOCLASS_ABOVE_NORMAL:
+        switch (priority) {
+        case THREAD_PRIORITY_IDLE: return 15 + priority - thread_base_priority;
+        case THREAD_PRIORITY_LOWEST: return 0 + priority - thread_base_priority;
+        case THREAD_PRIORITY_BELOW_NORMAL: return -2 + priority - thread_base_priority;
+        case THREAD_PRIORITY_NORMAL: return -4 + priority - thread_base_priority;
+        case THREAD_PRIORITY_ABOVE_NORMAL: return -6 + priority - thread_base_priority;
+        case THREAD_PRIORITY_HIGHEST: return -8 + priority - thread_base_priority;
+        case THREAD_PRIORITY_TIME_CRITICAL: return -15 + priority - thread_base_priority;
+        }
+    case PROCESS_PRIOCLASS_HIGH:
+        switch (priority) {
+        case THREAD_PRIORITY_IDLE: return 15 + priority - thread_base_priority;
+        case THREAD_PRIORITY_LOWEST: return -2 + priority - thread_base_priority;
+        case THREAD_PRIORITY_BELOW_NORMAL: return -4 + priority - thread_base_priority;
+        case THREAD_PRIORITY_NORMAL: return -6 + priority - thread_base_priority;
+        case THREAD_PRIORITY_ABOVE_NORMAL: return -8 + priority - thread_base_priority;
+        case THREAD_PRIORITY_HIGHEST: return -10 + priority - thread_base_priority;
+        case THREAD_PRIORITY_TIME_CRITICAL: return -15 + priority - thread_base_priority;
+        }
+    // PROCESS_PRIOCLASS_REALTIME => SCHED_FIFO:
+    //
+    // these return values shift the windows priorities to map with SCHED_FIFO + WINE_RT_PRIO value.
+    // There is a 'step' in the shift, so that the highest few THREAD_PRIORITY_* are more
+    // closely bounded to THREAD_PRIORITY_TIME_CRITICAL.
+    //
+    // each priority ends up being 1-2 apart. WINE_RT_PRIO and WINESERVER_RT should be
+    // about 4 apart. As there needs to be a tiny bit of headroom. ie:
+    //
+    // export WINESERVER_RT_PRIO=72
+    // export WINE_RT_PRIO=68
+    //
+    // Decremental; wineserver => APC futex => PROCESS_PRIOCLASS_REALTIME threads
+    
+    case PROCESS_PRIOCLASS_REALTIME:
+        switch (priority) {
+        case THREAD_PRIORITY_IDLE: return -9 + priority + thread_base_priority;
+        case -7: return -8 + priority + thread_base_priority;
+        case -6: return -8 + priority + thread_base_priority;
+        case -5: return -8 + priority + thread_base_priority;
+        case -4: return -7 + priority + thread_base_priority;
+        case -3: return -7 + priority + thread_base_priority;
+        case THREAD_PRIORITY_LOWEST: return -6 + priority + thread_base_priority;
+        case THREAD_PRIORITY_BELOW_NORMAL: return -5 + priority + thread_base_priority;
+        case THREAD_PRIORITY_NORMAL: return -4 + priority + thread_base_priority;
+        case THREAD_PRIORITY_ABOVE_NORMAL: return -3 + priority + thread_base_priority;
+        case THREAD_PRIORITY_HIGHEST: return -2 + priority + thread_base_priority;
+        case 3: return -20 + priority + thread_base_priority;
+        case 4: return -19 + priority + thread_base_priority;
+        case 5: return -18 + priority + thread_base_priority;
+        case 6: return -17 + priority + thread_base_priority;  
+        case THREAD_PRIORITY_TIME_CRITICAL: return -16 + priority + thread_base_priority;
+        }
+    }
+    return 0;
+}
+#endif
+
 #define THREAD_PRIORITY_REALTIME_HIGHEST 6
 #define THREAD_PRIORITY_REALTIME_LOWEST -7
 
+// set thread priority uses get_unix_priority() to get the values.
+int set_thread_priority( struct thread* thread, int priority )
+{
+    int max = THREAD_PRIORITY_HIGHEST;
+    int min = THREAD_PRIORITY_LOWEST;
+    if (thread->process->priority == PROCESS_PRIOCLASS_REALTIME)
+    {
+       min = THREAD_PRIORITY_REALTIME_LOWEST;
+       max = THREAD_PRIORITY_REALTIME_HIGHEST;  
+    }
+
+    if ((priority < min || priority > max) &&
+        priority != THREAD_PRIORITY_IDLE &&
+        priority != THREAD_PRIORITY_TIME_CRITICAL)
+    {
+        errno = EINVAL;
+        return -1;
+    }
+
+    thread->priority = priority;
+    if (thread->unix_tid == -1)
+        return 0;
+
+    // We only care about PROCESS_PRIOCLASS_REALTIME processes/threads.
+    // Set the SCHED_FIFO Priorities mapped from get_unix_priority()
+    //
+    // NOTE: for other windows prioclasses, we set the priorities + niceness 
+    // for their corresponding SCHED_OTHER threads.
+
+    if (thread->process->priority == PROCESS_PRIOCLASS_REALTIME)
+    {
+#ifdef HAVE_SCHED_SETSCHEDULER
+        struct sched_param param;
+        if (sched_getparam( thread->unix_tid, &param ) != 0)
+            goto error;
+
+        param.sched_priority = get_unix_priority( thread->process->priority, priority );
+        if (sched_setscheduler( thread->unix_tid, SCHED_FIFO|SCHED_RESET_ON_FORK, &param ) == 0)
+            return 0;
+#endif
+#ifdef HAVE_DBUS_DBUS_H
+        if (rtkit_set_realtime( thread->unix_pid, thread->unix_tid,
+                                get_unix_priority( thread->process->priority, priority ) ) == 0)
+            return 0;
+#endif
+    }
+    else
+    {
+#ifdef HAVE_SETPRIORITY
+        if (setpriority( PRIO_PROCESS, thread->unix_tid,
+                         get_unix_priority( thread->process->priority, priority ) ) == 0)
+            return 0;
+#endif
+#ifdef HAVE_DBUS_DBUS_H
+        if (rtkit_set_niceness( thread->unix_pid, thread->unix_tid,
+                                get_unix_priority( thread->process->priority, priority ) ) == 0)
+            return 0;
+#endif
+    }
+
+error:
+    return 0;
+}
+
 /* set all information about a thread */
 static void set_thread_info( struct thread *thread,
                              const struct set_thread_info_request *req )
 {
     if (req->mask & SET_THREAD_INFO_PRIORITY)
     {
+    // The below chunk is needed for set_scheduler_priority(). while it won't 
+    // ultimately set the final priorities, it does set things up for set_thread_priority()
+    // which will correct priority / match windows much closer. (including for SCHED_OTHER threads).
+    // We also need this for wineserver RT priority.
         int max = THREAD_PRIORITY_HIGHEST;
         int min = THREAD_PRIORITY_LOWEST;
-        if (thread->process->priority == PROCESS_PRIOCLASS_REALTIME)
+        if ((thread->process->priority = PROCESS_PRIOCLASS_REALTIME))
         {
             max = THREAD_PRIORITY_REALTIME_HIGHEST;
             min = THREAD_PRIORITY_REALTIME_LOWEST;
         }
-        if ((req->priority >= min && req->priority <= max) ||
-            req->priority == THREAD_PRIORITY_IDLE ||
-            req->priority == THREAD_PRIORITY_TIME_CRITICAL)
+        if ((req->priority < min || req->priority > max) &&
+            req->priority != THREAD_PRIORITY_IDLE &&
+            req->priority != THREAD_PRIORITY_TIME_CRITICAL)
+        {    
             thread->priority = req->priority;
-        else
-            set_error( STATUS_INVALID_PARAMETER );
+            set_scheduler_priority( thread );
+        }
+        if (set_thread_priority( thread, req->priority ))
+            file_set_error();
     }
     if (req->mask & SET_THREAD_INFO_AFFINITY)
     {
@@ -1570,6 +1900,7 @@ DECL_HANDLER(init_thread)
             process->unix_pid = -1;  /* can happen with linuxthreads */
         init_thread_context( current );
         generate_debug_event( current, CREATE_THREAD_DEBUG_EVENT, &req->entry );
+        set_thread_priority( current, current->priority );
         set_thread_affinity( current, current->affinity );
     }
     debug_level = max( debug_level, req->debug_level );
diff -pur a/server/thread.h b/server/thread.h
--- a/server/thread.h	2020-06-14 00:22:49.450573000 -0400
+++ b/server/thread.h	2020-06-15 20:30:46.121759676 -0400
@@ -160,4 +160,9 @@ static inline thread_id_t get_thread_id(
 static inline int get_thread_unix_tid( struct thread *thread ) { return thread->unix_tid; }
 static inline timeout_t get_thread_creation_time( struct thread *thread ) { return thread->creation_time; }
 
+/* scheduler functions */
+
+extern void init_scheduler( void );
+extern void set_scheduler_priority( struct thread *thread );
+
 #endif  /* __WINE_SERVER_THREAD_H */
diff -Npur -x '*.orig *.rej' a/server/scheduler.c b/server/scheduler.c
--- a/server/scheduler.c	1969-12-31 19:00:00.000000000 -0500
+++ b/server/scheduler.c	2020-06-16 17:40:54.126942188 -0400
@@ -0,0 +1,161 @@
+/*
+ * Scheduler priority management
+ *
+ * Copyright (C) 2015 Joakim Hernberg
+ * Copyright (C) 2015 Sebastian Lackner
+ * Copyright (C) 2020 Jordan Johnston
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#define _GNU_SOURCE  /* for SCHED_BATCH, SCHED_IDLE */
+#include <assert.h>
+#include <stdio.h>
+#include <stdarg.h>
+#ifdef HAVE_SYS_RESOURCE_H
+# include <sys/resource.h>
+#endif
+#ifdef HAVE_SCHED_H
+# include <sched.h>
+#endif
+#ifndef SCHED_RESET_ON_FORK
+# define SCHED_RESET_ON_FORK 0x40000000
+#endif
+#ifndef SCHED_IDLE
+ #define SCHED_IDLE 5
+#endif
+
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+#include "winternl.h"
+#include "thread.h"
+
+#if defined(__linux__) && defined(HAVE_SYS_RESOURCE_H) && defined(HAVE_SCHED_H)
+
+static int thread_base_priority = -1;
+
+/* gets the priority value from an environment variable */
+static int get_priority( const char *variable, int min, int max )
+{
+    const char *env;
+    int val;
+
+    env = getenv( variable );
+    if (!env) return -1;
+
+    val = atoi( env );
+    if (val >= min && val <= max) return val;
+    fprintf( stderr, "wineserver: %s should be between %d and %d\n", variable, min, max );
+    return -1;
+}
+
+/* initializes the scheduler */
+void init_scheduler( void )
+{
+    int min, max, priority;
+
+    min = sched_get_priority_min( SCHED_FIFO );
+    max = sched_get_priority_max( SCHED_FIFO );
+    if (min == -1 || max == -1)
+        return;
+
+    /* change the wineserver priority */
+    if ((priority = get_priority( "WINESERVER_RT_PRIO", min, max -1 )) != -1)
+    {
+        struct sched_param param;
+        memset( &param, 0, sizeof(param) );
+        param.sched_priority = priority;
+        if (sched_setscheduler( 0, SCHED_FIFO | SCHED_RESET_ON_FORK, &param ) == -1 &&
+            sched_setscheduler( 0, SCHED_FIFO, &param ) == -1)
+        {
+            fprintf( stderr, "wineserver: failed to change priority to SCHED_FIFO/%d\n",
+                     param.sched_priority );
+            /* do not bother to check the rest */
+            return;
+        }
+
+        if (debug_level) fprintf( stderr, "wineserver: changed priority to SCHED_FIFO/%d\n",
+                                  param.sched_priority );
+    }
+
+    /* determine base priority which will be used for all threads */
+    if ((priority = get_priority( "WINE_RT_PRIO", min, max - 4)) != -1)
+    {
+        thread_base_priority = priority;
+
+        if (debug_level) fprintf( stderr, "wineserver: initialized max user thread priority to %d\n",
+                                  thread_base_priority );
+    }
+}
+
+/* sets the scheduler priority of a windows thread */
+void set_scheduler_priority( struct thread *thread )
+{
+    struct sched_param param;
+    int policy;
+
+    if (thread_base_priority == -1) return;
+    if (thread->unix_tid == -1) return;
+    
+    // NOTE: we have a working implementation of PROCESS_PRIOCLASS_REALTIME mapped
+    // to SCHED_FIFO. That logic is in get_unix_priority() => set_thread_priority()
+    // found in server/thread.c
+    //
+    // We only really care about PROCESS_PRIOCLASS_REALTIME. Implementing any other
+    // PROCESS_PRIOCLASS_* to SCHED_FIFO would hurt performance badly. (obviously).
+    //
+    // SCHED_OTHER threads can also have their priority + niceness set. (eg: 0, -20).
+    // some threads will be set this way. (again, see server/thread.c)
+    //
+    // all logic from the STAGING_RT patch is therefore removed.
+    
+    memset( &param, 0, sizeof(param) );
+    if (thread->priority != PROCESS_PRIOCLASS_REALTIME)
+    {
+        policy = SCHED_OTHER;
+    }    
+    else
+    {
+        policy = SCHED_FIFO;
+        param.sched_priority = thread_base_priority;
+    }
+
+    if (sched_setscheduler(thread->unix_tid, policy | SCHED_RESET_ON_FORK, &param) == -1 &&
+        sched_setscheduler(thread->unix_tid, policy, &param) == -1)
+    {
+        static int once;
+        if (debug_level || !once++)
+            fprintf( stderr, "%04x: failed to change priority to %d/%d\n",
+                     thread->id, policy, param.sched_priority );
+        return;
+    }
+
+    if (debug_level) fprintf( stderr, "%04x: changed priority to %d/%d\n",
+                              thread->id, policy, param.sched_priority );
+}
+
+#else
+
+void init_scheduler( void )
+{
+}
+
+void set_scheduler_priority( struct thread *thread )
+{
+}
+
+#endif
