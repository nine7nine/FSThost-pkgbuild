 - Add support for setting RT policy.
 
 This is set with WINE_RT_POLICY=FF (or RR). FF is SCHED_FIFO, RR is SCHED_RR.
 
 I want to be able to test both. so having it set from the environment is needed.
 My basic understanding of the windows scheduler, is that it's actually closer to
 being Round-Robin, than it is to First-In-First-out. 
 
 Initial observations is that there isn't a noticeable difference, but I haven't
 investigated to closely yet. I also haven't adjusted the RR timeslice or anything 
 like that. * I'll considate this stuff later, when i rebase on newer wine.
 
 - rename realtime function in ntdll. it makes more sense to call it;
 
   set_pthreads_realtime()
   
 - Only set PROCESS_PRIOCLASS_REALTIME for RT. no need to set 
   THREAD_PRIORITY_TIME_CRITICAL. (values for these can be tweaked in function
   get_unix_pirioty()).
   
 johnstonjordan <At> gmail <dot> com   

diff -pur a/server/scheduler.c b/server/scheduler.c
--- a/server/scheduler.c	2020-06-26 02:09:10.995577272 -0400
+++ b/server/scheduler.c	2020-06-26 01:34:18.021806668 -0400
@@ -47,6 +47,7 @@
 #if defined(__linux__) && defined(HAVE_SYS_RESOURCE_H) && defined(HAVE_SCHED_H)
 
 static int thread_base_priority = -1;
+static int wine_rt_policy = -1;
 
 /* gets the priority value from an environment variable */
 static int get_priority( const char *variable, int min, int max )
@@ -66,21 +67,29 @@ static int get_priority( const char *var
 /* initializes the scheduler */
 void init_scheduler( void )
 {
-    int min, max, priority;
+    const char *policyStr = getenv("WINE_RT_POLICY");
 
+    int min, max, priority;
     min = sched_get_priority_min( SCHED_FIFO );
     max = sched_get_priority_max( SCHED_FIFO );
     if (min == -1 || max == -1)
         return;
+ 
+    if (policyStr) {
+        if (strcmp(policyStr, "RR")==0)
+            wine_rt_policy = SCHED_RR;
+        else if (strcmp(policyStr, "FF")==0)
+            wine_rt_policy = SCHED_FIFO;
+    } 
 
     /* change the wineserver priority */
-    if ((priority = get_priority( "WINE_RT_PRIO", min, max )) != -1)
-    {
+    if ((priority = get_priority( "WINE_RT_PRIO", min, max -1)) != -1)
+    {       
         struct sched_param param;
         memset( &param, 0, sizeof(param) );
         param.sched_priority = priority;
-        if (sched_setscheduler( 0, SCHED_FIFO | SCHED_RESET_ON_FORK, &param ) == -1 &&
-            sched_setscheduler( 0, SCHED_FIFO, &param ) == -1)
+        if (sched_setscheduler( 0, wine_rt_policy | SCHED_RESET_ON_FORK, &param ) == -1 &&
+            sched_setscheduler( 0, wine_rt_policy, &param ) == -1)
         {
             fprintf( stderr, "wineserver: failed to change priority to SCHED_FIFO/%d\n",
                      param.sched_priority );
@@ -105,8 +114,15 @@ void init_scheduler( void )
 /* sets the scheduler priority of a windows thread */
 void set_scheduler_priority( struct thread *thread )
 {
+    const char *policyStr = getenv("WINE_RT_POLICY");
     struct sched_param param;
-    int policy;
+
+    if (policyStr) {
+        if (strcmp(policyStr, "RR")==0)
+            wine_rt_policy = SCHED_RR;
+        else if (strcmp(policyStr, "FF")==0)
+            wine_rt_policy = SCHED_FIFO;
+    } 
 
     if (thread_base_priority == -1) return;
     if (thread->unix_tid == -1) return;
@@ -119,7 +135,7 @@ void set_scheduler_priority( struct thre
     //
     // NOTE: we can get the thread ids from thread->fsync_idx (and also unix_tid, as usual).
     //
-    // We only really care about PROCESS_PRIOCLASS_REALTIME. Implementing any other
+    // We only really care about PROCESS_PRIOCLASS_REALTIME. that's it! Implementing any other
     // PROCESS_PRIOCLASS_* to SCHED_FIFO would hurt RT performance badly. (obviously).
     //
     // SCHED_OTHER threads can also have their priority + niceness set. (eg: 0, -20).
@@ -127,40 +143,38 @@ void set_scheduler_priority( struct thre
     //
     // most logic from the STAGING_RT patch is therefore removed.
     
-    // 
     memset( &param, 0, sizeof(param) );
-    if ((thread->priority = PROCESS_PRIOCLASS_REALTIME || THREAD_PRIORITY_TIME_CRITICAL))
+    if ((thread->priority = PROCESS_PRIOCLASS_REALTIME))
     {
-        policy = SCHED_FIFO;
         param.sched_priority = thread_base_priority -1;
     } 
     else
     {
-        policy = SCHED_OTHER;
+        wine_rt_policy = SCHED_OTHER;
     }
 
-    if (sched_setscheduler(thread->unix_tid, policy | SCHED_RESET_ON_FORK, &param) == -1 &&
-        sched_setscheduler(thread->unix_tid, policy, &param) == -1)
+    if (sched_setscheduler(thread->unix_tid, wine_rt_policy | SCHED_RESET_ON_FORK, &param) == -1 &&
+        sched_setscheduler(thread->unix_tid, wine_rt_policy, &param) == -1)
     {
         static int once;
         if (debug_level || !once++)
             fprintf( stderr, "%04x: failed to change priority to %d/%d\n",
-                     thread->id, policy, param.sched_priority );
+                     thread->id, wine_rt_policy, param.sched_priority );
         return;
     }
     // we care about the fsync_idx threads, in fact; they are critical (don't mind the pun).
-    if (sched_setscheduler(thread->fsync_idx, policy | SCHED_RESET_ON_FORK, &param) == -1 &&
-        sched_setscheduler(thread->fsync_idx, policy, &param) == -1)
+    if (sched_setscheduler(thread->fsync_idx, wine_rt_policy | SCHED_RESET_ON_FORK, &param) == -1 &&
+        sched_setscheduler(thread->fsync_idx, wine_rt_policy, &param) == -1)
     {
         static int once;
         if (debug_level || !once++)
             fprintf( stderr, "%04x: failed to change priority to %d/%d\n",
-                     thread->id, policy, param.sched_priority );
+                     thread->id, wine_rt_policy, param.sched_priority );
         return;
     }
 
     if (debug_level) fprintf( stderr, "%04x: changed priority to %d/%d\n",
-                              thread->id, policy, param.sched_priority );
+                              thread->id, wine_rt_policy, param.sched_priority );
 }
 
 #else
diff -pur a/server/thread.c b/server/thread.c
--- a/server/thread.c	2020-06-23 02:13:08.574101886 -0400
+++ b/server/thread.c	2020-06-26 01:33:26.471470775 -0400
@@ -492,7 +492,7 @@ struct thread *create_thread( int fd, st
     thread->desktop = process->desktop;
     thread->affinity = process->affinity;
     // return the priority here
-    thread->priority = process->priority;
+    // thread->priority = process->priority;
     if (!current) current = thread;
 
     list_add_head( &thread_list, &thread->entry );
@@ -903,9 +903,12 @@ static int get_unix_priority( int priori
 #define THREAD_PRIORITY_REALTIME_HIGHEST 6
 #define THREAD_PRIORITY_REALTIME_LOWEST -7
 
-// set thread priority uses get_unix_priority() to get the unix values.
+static int wine_rt_policy = -1;
+
+// set thread priority uses get_unix_priority() to get the unix values.
 int set_thread_priority( struct thread* thread, int priority )
 {
+    const char *policyStr = getenv("WINE_RT_POLICY");
     int max = THREAD_PRIORITY_HIGHEST;
     int min = THREAD_PRIORITY_LOWEST;
     if (thread->process->priority == PROCESS_PRIOCLASS_REALTIME)
@@ -927,6 +930,13 @@ int set_thread_priority( struct thread*
     // catch the fsync_idx (unix_tid)
     if (thread->fsync_idx == -1)
             return 0;
+            
+    if (policyStr) {
+        if (strcmp(policyStr, "RR")==0)
+            wine_rt_policy = SCHED_RR;
+        else if (strcmp(policyStr, "FF")==0)
+            wine_rt_policy = SCHED_FIFO;
+    }            
 
     // We only care about PROCESS_PRIOCLASS_REALTIME processes/threads.
     // Set the SCHED_FIFO Priorities mapped from get_unix_priority()
@@ -946,9 +956,9 @@ int set_thread_priority( struct thread*
             goto error;
 
         param.sched_priority = get_unix_priority( thread->process->priority, priority );
-        if (sched_setscheduler( thread->unix_tid, SCHED_FIFO|SCHED_RESET_ON_FORK, &param ) == 0)
+        if (sched_setscheduler( thread->unix_tid, wine_rt_policy|SCHED_RESET_ON_FORK, &param ) == 0)
             return 0;
-        if (sched_setscheduler( thread->fsync_idx, SCHED_FIFO|SCHED_RESET_ON_FORK, &param ) == 0)
+        if (sched_setscheduler( thread->fsync_idx, wine_rt_policy|SCHED_RESET_ON_FORK, &param ) == 0)
             return 0;
 #endif
 #ifdef HAVE_DBUS_DBUS_H
@@ -991,7 +1001,7 @@ static void set_thread_info( struct thre
     if (req->mask & SET_THREAD_INFO_PRIORITY)
     {
     // The below chunk is needed for set_scheduler_priority(). while it won't 
-    // ultimately set the final priorities, it triggers threads to be set with set_thread_priority()
+    // ultimately set the final priorities, it sets things up for set_thread_priority()
     // which will correct priority / match windows much closer. (including for SCHED_OTHER threads).
     // We also need this for wineserver RT priority.
         int max = THREAD_PRIORITY_HIGHEST;
diff -pur a/dlls/ntdll/thread.c b/dlls/ntdll/thread.c
--- a/dlls/ntdll/thread.c	2020-06-23 02:13:08.573101878 -0400
+++ b/dlls/ntdll/thread.c	2020-06-26 01:11:21.055795042 -0400
@@ -78,22 +78,30 @@ static int get_priority( const char *var
 }
 
 static int priority;
+static int wine_rt_policy = -1;
 
-int pthread_set_rt_priority (pthread_t pthread_id, int policy, int priority)
+int set_pthreads_realtime (pthread_t pthread_id, int wine_rt_policy, int priority)
 {
+    const char *policyStr = getenv("WINE_RT_POLICY");
     int min, max, apc_priority;
-
     min = sched_get_priority_min( SCHED_FIFO );
     max = sched_get_priority_max( SCHED_FIFO );
 
+    if (policyStr) {
+        if (strcmp(policyStr, "RR")==0)
+            wine_rt_policy = SCHED_RR;
+        else if (strcmp(policyStr, "FF")==0)
+            wine_rt_policy = SCHED_FIFO;
+    }
+   
     if ((apc_priority = get_priority( "WINE_RT_PRIO", min, max )) != -1)
     {
         thread_apc_priority = apc_priority;
     }
 	struct sched_param param;	
-	param.sched_priority = thread_apc_priority;
+	param.sched_priority = thread_apc_priority -1;
 
-	return pthread_setschedparam (pthread_id, SCHED_FIFO, &param);
+	return pthread_setschedparam (pthread_id, wine_rt_policy, &param);
 }
 #endif
 
@@ -781,8 +789,8 @@ NTSTATUS WINAPI NtCreateThreadEx( HANDLE
 #if FSYNC_RT
     // needed for setting SCHED_FIFO for the APC futex
     struct sched_param parm;
-    int policy = 0;
-    pthread_attr_setschedpolicy (&pthread_attr, policy);
+    int wine_rt_policy = 0;
+    pthread_attr_setschedpolicy (&pthread_attr, wine_rt_policy);
     pthread_attr_setschedparam (&pthread_attr, &parm);
 #endif
     BOOLEAN suspended = !!(flags & THREAD_CREATE_FLAGS_CREATE_SUSPENDED);
@@ -963,7 +971,8 @@ NTSTATUS WINAPI NtCreateThreadEx( HANDLE
         // this may be redundant, but set PTHREAD_EXPLICIT_SCHED for the
         // fsync APC futex.
         pthread_attr_setinheritsched(&pthread_attr, PTHREAD_EXPLICIT_SCHED);
-    	pthread_set_rt_priority(validFsyncIdx, policy, priority);
+        // set realtime threads
+    	set_pthreads_realtime(validFsyncIdx, wine_rt_policy, priority);
     	}
     else
         WARN("no RT for pthread");
