 - Force SCHED_FIFO on Wineserver, kernel-mode APC and TIME_CRITICAL threads.
 - the slightly lower priority PROCESS_PRIOCLASS_REALTIME threads can be set
   to SCHED_FIFO or SCHED_RR (RR is recommended).
   
   The most important FIFO threads in Wine and applications run at the same 
   priority (thinking about synchronization here, too), while other other lower 
   realtime prioclass threads, can use the Round-Robin scheduling algorithm or
   First-In-Fist-Out.
   
   RR more closely mimics Windows' behaviour for highest priority threads, but 
   I think it makes more sense for wine's 'backbone' / and our application's 
   most critical threads to be FIFO. 
   
   From what I'm observing; other lower priority threads may actually 
   benefit from being set SCHED_RR. it's more even with CPU time. Additionally, 
   i can tune the quantum, i want to.
   
 - add/remove comments / fixups.
 
 johnstonlojradan <AT> gmail <DOT> com

diff -pur a/dlls/ntdll/thread.c b/dlls/ntdll/thread.c
--- a/dlls/ntdll/thread.c	2020-06-27 12:49:00.007369000 -0400
+++ b/dlls/ntdll/thread.c	2020-06-30 23:17:07.604422185 -0400
@@ -78,20 +78,18 @@ static int get_priority( const char *var
 }
 
 static int priority;
-static int wine_rt_policy = -1;
 
 int set_pthreads_realtime (pthread_t pthread_id, int wine_rt_policy, int priority)
 {
+    // Get RT policy
     const char *policyStr = getenv("WINE_RT_POLICY");
     int min, max, apc_priority;
     min = sched_get_priority_min( SCHED_FIFO );
     max = sched_get_priority_max( SCHED_FIFO );
 
+    // hardcoded to SCHED_FIFO
     if (policyStr) {
-        if (strcmp(policyStr, "RR")==0)
-            wine_rt_policy = SCHED_RR;
-        else if (strcmp(policyStr, "FF")==0)
-            wine_rt_policy = SCHED_FIFO;
+       wine_rt_policy = SCHED_FIFO;
     }
    
     if ((apc_priority = get_priority( "WINE_RT_PRIO", min, max )) != -1)
diff -pur a/server/scheduler.c b/server/scheduler.c
--- a/server/scheduler.c	2020-06-27 12:49:00.003369000 -0400
+++ b/server/scheduler.c	2020-06-30 23:50:37.720763848 -0400
@@ -75,6 +75,7 @@ void init_scheduler( void )
     if (min == -1 || max == -1)
         return;
  
+    // Set RT policy.
     if (policyStr) {
         if (strcmp(policyStr, "RR")==0)
             wine_rt_policy = SCHED_RR;
@@ -88,6 +89,9 @@ void init_scheduler( void )
         struct sched_param param;
         memset( &param, 0, sizeof(param) );
         param.sched_priority = priority;
+        // hardcode to SCHED_FIFO for wineserver.
+        wine_rt_policy = SCHED_FIFO;
+        
         if (sched_setscheduler( 0, wine_rt_policy | SCHED_RESET_ON_FORK, &param ) == -1 &&
             sched_setscheduler( 0, wine_rt_policy, &param ) == -1)
         {
@@ -117,6 +121,7 @@ void set_scheduler_priority( struct thre
     const char *policyStr = getenv("WINE_RT_POLICY");
     struct sched_param param;
 
+    // set the RT policy
     if (policyStr) {
         if (strcmp(policyStr, "RR")==0)
             wine_rt_policy = SCHED_RR;
@@ -126,15 +131,12 @@ void set_scheduler_priority( struct thre
 
     if (thread_base_priority == -1) return;
     if (thread->unix_tid == -1) return;
-    // that's right boy - grab the fsync_idx, if it exists (unix_tid, duh).
     if (thread->fsync_idx == -1) return;
     
     // NOTE: we have a working implementation of PROCESS_PRIOCLASS_REALTIME mapped
     // to SCHED_FIFO. That logic is in get_unix_priority() => set_thread_priority()
     // found in server/thread.c
     //
-    // NOTE: we can get the thread ids from thread->fsync_idx (and also unix_tid, as usual).
-    //
     // We only really care about PROCESS_PRIOCLASS_REALTIME. that's it! Implementing any other
     // PROCESS_PRIOCLASS_* to SCHED_FIFO would hurt RT performance badly. (obviously).
     //
@@ -144,8 +146,15 @@ void set_scheduler_priority( struct thre
     // simplify the logic from the STAGING_RT patch. realtime or other, that's it!
     
     memset( &param, 0, sizeof(param) );
-    if ((thread->priority = PROCESS_PRIOCLASS_REALTIME))
+    // Any RT thread that isn't TIME_CRITICAL is set to lower priority and can use RR/FF RT Policies.
+    if ((thread->priority = PROCESS_PRIOCLASS_REALTIME && thread->priority != THREAD_PRIORITY_TIME_CRITICAL ))
+    {
+        param.sched_priority = thread_base_priority -1;
+    }
+    // Hardcoded to SCHED_FIFO just for TIME_CRITICAL here.
+    if ((thread->priority = PROCESS_PRIOCLASS_REALTIME && THREAD_PRIORITY_TIME_CRITICAL ))
     {
+        wine_rt_policy = SCHED_FIFO;
         param.sched_priority = thread_base_priority -1;
     } 
     else
diff -pur a/server/thread.c b/server/thread.c
--- a/server/thread.c	2020-06-27 12:49:00.003369000 -0400
+++ b/server/thread.c	2020-06-30 23:20:04.244620889 -0400
@@ -908,6 +908,7 @@ static int wine_rt_policy = -1;
 // set thread priority uses get_unix_priority() to get the unix values.
 int set_thread_priority( struct thread* thread, int priority )
 {
+    // Get RT policy
     const char *policyStr = getenv("WINE_RT_POLICY");
     int max = THREAD_PRIORITY_HIGHEST;
     int min = THREAD_PRIORITY_LOWEST;
@@ -927,10 +928,11 @@ int set_thread_priority( struct thread*
 
     thread->priority = priority;
     if (thread->unix_tid == -1)
-    // catch the fsync_idx (unix_tid)
+    // catch an fsync_idx.
     if (thread->fsync_idx == -1)
             return 0;
-            
+    
+    // Set the RT policy      
     if (policyStr) {
         if (strcmp(policyStr, "RR")==0)
             wine_rt_policy = SCHED_RR;
@@ -1000,10 +1002,6 @@ static void set_thread_info( struct thre
 {
     if (req->mask & SET_THREAD_INFO_PRIORITY)
     {
-    // The below chunk is needed for set_scheduler_priority(). while it won't 
-    // ultimately set the final priorities, it sets things up for set_thread_priority()
-    // which will correct priority / match windows much closer. (including for SCHED_OTHER threads).
-    // We also need this for wineserver RT priority.
         int max = THREAD_PRIORITY_HIGHEST;
         int min = THREAD_PRIORITY_LOWEST;
         if ((thread->process->priority = PROCESS_PRIOCLASS_REALTIME))
@@ -1016,7 +1014,7 @@ static void set_thread_info( struct thre
             req->priority == THREAD_PRIORITY_TIME_CRITICAL)
         {    
             thread->priority = req->priority;
-            // set FIFO threads
+            // set RT threads. see: scheduler.c
             set_scheduler_priority( thread );
         }         
         if (set_thread_priority( thread, req->priority ))
