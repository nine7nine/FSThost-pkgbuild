This patch does a few things;

 - gets rid of WINESERVER_RT_PRIO env variable
 
I disallow changing the apc and wineserver independently. It would be quite stupid
to allow users to change wineserver, the apc futex threads or the realtime process threads
independently... No matter how you cut it; the APC needs to be higher than the process
threads and wineserver needs to be higher than the APC.

  - ntdll: reduce the time used in usleep() call. 100 still gives it enough time.
  - Adjust the priority steps between wineserver, the Apc futex threads && realtime
    processes.
  - make WINE_RT_PRIO be a maximum value, instead of a base priority.
  - more work on get_unix_priority()
  
This is tricky to figure out, as I am mapping within 0-99 range. Posix seems to 
say that i should have a spacing of (2), so I've done that -- but the processes
themselves will return their windows priority values, so I have to do some
accounting to get the correct returns for unix.

the last version had this wrong, in particular for the IDLE and realtime classes;
case: 4 thru 6. So I've corrected these now. Still not positive about case: -3 
thru -7 -- It might be right, it might be wrong. (or may be right by fluke).

diff -Pur a/dlls/ntdll/thread.c b/dlls/ntdll/thread.c
--- a/dlls/ntdll/thread.c	2020-06-16 21:20:32.729139441 -0400
+++ b/dlls/ntdll/thread.c	2020-06-21 01:43:18.847538442 -0400
@@ -86,8 +86,7 @@
     min = sched_get_priority_min( SCHED_FIFO );
     max = sched_get_priority_max( SCHED_FIFO );
 
-    // use WINESERVER_RT_PRIO for now. change this later. 
-    if ((apc_priority = get_priority( "WINESERVER_RT_PRIO", min, max + 3 )) != -1)
+    if ((apc_priority = get_priority( "WINE_RT_PRIO", min, max -8 )) != -1)
     {
         thread_apc_priority = apc_priority;
     }
@@ -957,7 +956,7 @@
         for (i = 0; i < 100; ++i) {
             validFsyncIdx = thread_data->fsync_apc_idx;
             if (validFsyncIdx == 0)
-                usleep(3000);
+                usleep(100);
         }
     }
     if (validFsyncIdx != 0) {
diff -Pur a/server/scheduler.c b/server/scheduler.c
--- a/server/scheduler.c	2020-06-16 21:20:32.727139000 -0400
+++ b/server/scheduler.c	2020-06-21 01:42:50.154265167 -0400
@@ -74,7 +74,7 @@
         return;
 
     /* change the wineserver priority */
-    if ((priority = get_priority( "WINESERVER_RT_PRIO", min, max -1 )) != -1)
+    if ((priority = get_priority( "WINE_RT_PRIO", min, max)) != -1)
     {
         struct sched_param param;
         memset( &param, 0, sizeof(param) );
@@ -93,7 +93,7 @@
     }
 
     /* determine base priority which will be used for all threads */
-    if ((priority = get_priority( "WINE_RT_PRIO", min, max - 4)) != -1)
+    if ((priority = get_priority( "WINE_RT_PRIO", min, max)) != -1)
     {
         thread_base_priority = priority;
 
@@ -116,7 +116,7 @@
     // found in server/thread.c
     //
     // We only really care about PROCESS_PRIOCLASS_REALTIME. Implementing any other
-    // PROCESS_PRIOCLASS_* to SCHED_FIFO would hurt performance badly. (obviously).
+    // PROCESS_PRIOCLASS_* to SCHED_FIFO would hurt RT performance badly. (obviously).
     //
     // SCHED_OTHER threads can also have their priority + niceness set. (eg: 0, -20).
     // some threads will be set this way. (again, see server/thread.c)
@@ -124,14 +124,14 @@
     // all logic from the STAGING_RT patch is therefore removed.
     
     memset( &param, 0, sizeof(param) );
-    if (thread->priority != PROCESS_PRIOCLASS_REALTIME)
-    {
-        policy = SCHED_OTHER;
-    }    
-    else
+    if (thread->priority = PROCESS_PRIOCLASS_REALTIME && THREAD_PRIORITY_TIME_CRITICAL)
     {
         policy = SCHED_FIFO;
         param.sched_priority = thread_base_priority;
+    } 
+    else
+    {
+        policy = SCHED_OTHER;
     }
 
     if (sched_setscheduler(thread->unix_tid, policy | SCHED_RESET_ON_FORK, &param) == -1 &&
diff -Pur a/server/thread.c b/server/thread.c
--- a/server/thread.c	2020-06-16 21:20:32.726139000 -0400
+++ b/server/thread.c	2020-06-21 01:30:04.630007082 -0400
@@ -491,6 +491,8 @@
     thread->process = (struct process *)grab_object( process );
     thread->desktop = process->desktop;
     thread->affinity = process->affinity;
+    // return the priority here
+    thread->priority = process->priority;
     if (!current) current = thread;
 
     list_add_head( &thread_list, &thread->entry );
@@ -797,7 +799,7 @@
     max = sched_get_priority_max( SCHED_FIFO );
 
     // RT priority for threads must be below APC futex and Wineserver.(ref: min, max -4)
-    if ((base_priority = get_priority( "WINE_RT_PRIO", min, max - 4 )) != -1)
+    if ((base_priority = get_priority( "WINE_RT_PRIO", min, max + 1 )) != -1)
     {
         thread_base_priority = base_priority;
     }
@@ -815,86 +817,92 @@
     switch (priority_class) {
     case PROCESS_PRIOCLASS_IDLE:
         switch (priority) {
-        case THREAD_PRIORITY_IDLE: return 15 + priority - thread_base_priority;
-        case THREAD_PRIORITY_LOWEST: return 10 + priority - thread_base_priority;
-        case THREAD_PRIORITY_BELOW_NORMAL: return 8 + priority - thread_base_priority;
-        case THREAD_PRIORITY_NORMAL: return 6 + priority - thread_base_priority;
-        case THREAD_PRIORITY_ABOVE_NORMAL: return 4 + priority - thread_base_priority;
-        case THREAD_PRIORITY_HIGHEST: return 2 + priority - thread_base_priority;
-        case THREAD_PRIORITY_TIME_CRITICAL: return -15 + priority - thread_base_priority;
+        case THREAD_PRIORITY_IDLE: return 15 + 5;
+        case THREAD_PRIORITY_LOWEST: return 10 + 5;
+        case THREAD_PRIORITY_BELOW_NORMAL: return 8 + 5;
+        case THREAD_PRIORITY_NORMAL: return 6 + 5;
+        case THREAD_PRIORITY_ABOVE_NORMAL: return 4 + 5;
+        case THREAD_PRIORITY_HIGHEST: return 2 + 5;
+        case THREAD_PRIORITY_TIME_CRITICAL: return -15 + 5;
         }
     case PROCESS_PRIOCLASS_BELOW_NORMAL:
         switch (priority) {
-        case THREAD_PRIORITY_IDLE: return 15 + priority - thread_base_priority;
-        case THREAD_PRIORITY_LOWEST: return 8 + priority - thread_base_priority;
-        case THREAD_PRIORITY_BELOW_NORMAL: return 6 + priority - thread_base_priority;
-        case THREAD_PRIORITY_NORMAL: return 4 + priority - thread_base_priority;
-        case THREAD_PRIORITY_ABOVE_NORMAL: return 2 + priority - thread_base_priority;
-        case THREAD_PRIORITY_HIGHEST: return 0 + priority - thread_base_priority;
-        case THREAD_PRIORITY_TIME_CRITICAL: return -15 + priority - thread_base_priority;
+        case THREAD_PRIORITY_IDLE: return 15 + 4;
+        case THREAD_PRIORITY_LOWEST: return 8 + 4;
+        case THREAD_PRIORITY_BELOW_NORMAL: return 6 + 2;
+        case THREAD_PRIORITY_NORMAL: return 4 + 4;
+        case THREAD_PRIORITY_ABOVE_NORMAL: return 2 + 2;
+        case THREAD_PRIORITY_HIGHEST: return 0 + 4;
+        case THREAD_PRIORITY_TIME_CRITICAL: return -15 + 2;
         }
     case PROCESS_PRIOCLASS_NORMAL:
         switch (priority) {
-        case THREAD_PRIORITY_IDLE: return 15 + priority - thread_base_priority;
-        case THREAD_PRIORITY_LOWEST: return 4 + priority - thread_base_priority;
-        case THREAD_PRIORITY_BELOW_NORMAL: return 2 + priority - thread_base_priority;
-        case THREAD_PRIORITY_NORMAL: return 0 + priority - thread_base_priority;
-        case THREAD_PRIORITY_ABOVE_NORMAL: return -2 + priority - thread_base_priority;
-        case THREAD_PRIORITY_HIGHEST: return -4 + priority - thread_base_priority;
-        case THREAD_PRIORITY_TIME_CRITICAL: return -15 + priority - thread_base_priority;
+        case THREAD_PRIORITY_IDLE: return 15;
+        case THREAD_PRIORITY_LOWEST: return 4;
+        case THREAD_PRIORITY_BELOW_NORMAL: return 2;
+        case THREAD_PRIORITY_NORMAL: return 0;
+        case THREAD_PRIORITY_ABOVE_NORMAL: return -2;
+        case THREAD_PRIORITY_HIGHEST: return -43;
+        case THREAD_PRIORITY_TIME_CRITICAL: return -15;
         }
     case PROCESS_PRIOCLASS_ABOVE_NORMAL:
         switch (priority) {
-        case THREAD_PRIORITY_IDLE: return 15 + priority - thread_base_priority;
-        case THREAD_PRIORITY_LOWEST: return 0 + priority - thread_base_priority;
-        case THREAD_PRIORITY_BELOW_NORMAL: return -2 + priority - thread_base_priority;
-        case THREAD_PRIORITY_NORMAL: return -4 + priority - thread_base_priority;
-        case THREAD_PRIORITY_ABOVE_NORMAL: return -6 + priority - thread_base_priority;
-        case THREAD_PRIORITY_HIGHEST: return -8 + priority - thread_base_priority;
-        case THREAD_PRIORITY_TIME_CRITICAL: return -15 + priority - thread_base_priority;
+        case THREAD_PRIORITY_IDLE: return 15 - 2;
+        case THREAD_PRIORITY_LOWEST: return 0 - 2;
+        case THREAD_PRIORITY_BELOW_NORMAL: return -2 - 2;
+        case THREAD_PRIORITY_NORMAL: return -4 - 2;
+        case THREAD_PRIORITY_ABOVE_NORMAL: return -6 - 2;
+        case THREAD_PRIORITY_HIGHEST: return -8 - 2;
+        case THREAD_PRIORITY_TIME_CRITICAL: return -15 - 2;
         }
     case PROCESS_PRIOCLASS_HIGH:
         switch (priority) {
-        case THREAD_PRIORITY_IDLE: return 15 + priority - thread_base_priority;
-        case THREAD_PRIORITY_LOWEST: return -2 + priority - thread_base_priority;
-        case THREAD_PRIORITY_BELOW_NORMAL: return -4 + priority - thread_base_priority;
-        case THREAD_PRIORITY_NORMAL: return -6 + priority - thread_base_priority;
-        case THREAD_PRIORITY_ABOVE_NORMAL: return -8 + priority - thread_base_priority;
-        case THREAD_PRIORITY_HIGHEST: return -10 + priority - thread_base_priority;
-        case THREAD_PRIORITY_TIME_CRITICAL: return -15 + priority - thread_base_priority;
+        case THREAD_PRIORITY_IDLE: return 15 - 4;
+        case THREAD_PRIORITY_LOWEST: return -2;
+        case THREAD_PRIORITY_BELOW_NORMAL: return -4;
+        case THREAD_PRIORITY_NORMAL: return -6 -4;
+        case THREAD_PRIORITY_ABOVE_NORMAL: return -8 - 4;
+        case THREAD_PRIORITY_HIGHEST: return -10  - 4 ;
+        case THREAD_PRIORITY_TIME_CRITICAL: return -15 - 4;
         }
     // PROCESS_PRIOCLASS_REALTIME => SCHED_FIFO:
     //
-    // these return values shift the windows priorities to map with SCHED_FIFO + WINE_RT_PRIO value.
-    // There is a 'step' in the shift, so that the highest few THREAD_PRIORITY_* are more
+    // these return values shift  around to map (somewhat analoguous) with SCHED_FIFO + WINE_RT_PRIO value.
+    // There are steps in the return values, because we are recieving these from the apps - they return
+    // what they do, then we remap them. note: that the highest few THREAD_PRIORITY_* are more
     // closely bounded to THREAD_PRIORITY_TIME_CRITICAL.
     //
-    // each priority ends up being 1-2 apart. WINE_RT_PRIO and WINESERVER_RT should be
-    // about 4 apart. As there needs to be a tiny bit of headroom. ie:
+    // base priority is set with  env WINE_RT_PRIO=70 wine foo
     //
-    // export WINESERVER_RT_PRIO=72
-    // export WINE_RT_PRIO=68
+    // each case return number is confusing, becuase Windows is confusing and doesn't map 
+    // very well to linux scheduler priorities. I think everything is correct now, but I'm
+    // not positive on case: -3 to -7 (??) ... Meaning, should I be adding from _IDLE and
+    // incrementing up to _LOWEST? -- or how it is now? or some step, just like from 
+    // _TIME_CRITICAL downward. (which seems to be correct now, fixes _IDLE too).
     //
-    // Decremental; wineserver => APC futex => PROCESS_PRIOCLASS_REALTIME threads
+    // Decremental RT prios; wineserver => APC futex threads => PROCESS_PRIOCLASS_REALTIME threads.
+    //
+    // NOTE: no longer allow messing with wineserver or the apc threads. They want to be where
+    // they are. I also have a hunch that it's beneficial to enforcing ordering (in terms of preemption).
     
     case PROCESS_PRIOCLASS_REALTIME:
         switch (priority) {
-        case THREAD_PRIORITY_IDLE: return -9 + priority + thread_base_priority;
-        case -7: return -8 + priority + thread_base_priority;
-        case -6: return -8 + priority + thread_base_priority;
-        case -5: return -8 + priority + thread_base_priority;
-        case -4: return -7 + priority + thread_base_priority;
-        case -3: return -7 + priority + thread_base_priority;
-        case THREAD_PRIORITY_LOWEST: return -6 + priority + thread_base_priority;
-        case THREAD_PRIORITY_BELOW_NORMAL: return -5 + priority + thread_base_priority;
-        case THREAD_PRIORITY_NORMAL: return -4 + priority + thread_base_priority;
-        case THREAD_PRIORITY_ABOVE_NORMAL: return -3 + priority + thread_base_priority;
-        case THREAD_PRIORITY_HIGHEST: return -2 + priority + thread_base_priority;
-        case 3: return -20 + priority + thread_base_priority;
-        case 4: return -19 + priority + thread_base_priority;
-        case 5: return -18 + priority + thread_base_priority;
-        case 6: return -17 + priority + thread_base_priority;  
-        case THREAD_PRIORITY_TIME_CRITICAL: return -16 + priority + thread_base_priority;
+        case THREAD_PRIORITY_IDLE: return 0; // set to zero.
+        case -7: return -14 + priority + thread_base_priority;
+        case -6: return -22 + priority + thread_base_priority;
+        case -5: return -20 + priority + thread_base_priority;
+        case -4: return -18 + priority + thread_base_priority;
+        case -3: return -16 + priority + thread_base_priority;
+        case THREAD_PRIORITY_LOWEST: return -14 + priority + thread_base_priority;
+        case THREAD_PRIORITY_BELOW_NORMAL: return -12 + priority + thread_base_priority;
+        case THREAD_PRIORITY_NORMAL: return -10 + priority + thread_base_priority;
+        case THREAD_PRIORITY_ABOVE_NORMAL: return -8 + priority + thread_base_priority;
+        case THREAD_PRIORITY_HIGHEST: return -6 + priority + thread_base_priority;
+        case 3: return -12 + priority + thread_base_priority;
+        case 4: return -10 + priority + thread_base_priority;
+        case 5: return -8 + priority + thread_base_priority;
+        case 6: return -6 + priority + thread_base_priority;  
+        case THREAD_PRIORITY_TIME_CRITICAL: return -18 + priority + thread_base_priority;
         }
     }
     return 0;
@@ -904,7 +912,7 @@
 #define THREAD_PRIORITY_REALTIME_HIGHEST 6
 #define THREAD_PRIORITY_REALTIME_LOWEST -7
 
-// set thread priority uses get_unix_priority() to get the values.
+// set thread priority uses get_unix_priority() to get the unix values.
 int set_thread_priority( struct thread* thread, int priority )
 {
     int max = THREAD_PRIORITY_HIGHEST;
@@ -925,10 +933,11 @@
 
     thread->priority = priority;
     if (thread->unix_tid == -1)
-        return 0;
+    if (thread->fsync_idx == -1)
+            return 0;
 
     // We only care about PROCESS_PRIOCLASS_REALTIME processes/threads.
-    // Set the SCHED_FIFO Priorities mapped from get_unix_priority()
+    // Set the SCHED_FIFO Priorities mapped from get_unix_priority()
     //
     // NOTE: for other windows prioclasses, we set the priorities + niceness 
     // for their corresponding SCHED_OTHER threads.
@@ -975,7 +984,7 @@
     if (req->mask & SET_THREAD_INFO_PRIORITY)
     {
     // The below chunk is needed for set_scheduler_priority(). while it won't 
-    // ultimately set the final priorities, it does set things up for set_thread_priority()
+    // ultimately set the final priorities, it triggers threads to be set with set_thread_priority()
     // which will correct priority / match windows much closer. (including for SCHED_OTHER threads).
     // We also need this for wineserver RT priority.
         int max = THREAD_PRIORITY_HIGHEST;
@@ -985,13 +994,14 @@
             max = THREAD_PRIORITY_REALTIME_HIGHEST;
             min = THREAD_PRIORITY_REALTIME_LOWEST;
         }
-        if ((req->priority < min || req->priority > max) &&
-            req->priority != THREAD_PRIORITY_IDLE &&
-            req->priority != THREAD_PRIORITY_TIME_CRITICAL)
+        if ((req->priority >= min && req->priority <= max) ||
+            req->priority == THREAD_PRIORITY_IDLE ||
+            req->priority == THREAD_PRIORITY_TIME_CRITICAL)
         {    
             thread->priority = req->priority;
+            // set FIFO threads
             set_scheduler_priority( thread );
-        }
+        }         
         if (set_thread_priority( thread, req->priority ))
             file_set_error();
     }
