In my build, i revert;

  ntdll-Store_fsync_APC_futex_in_the_thread_data_directly.patch
  
this is so I can test setting RT priority within ntdll. But in order to do that,
I need a pthread_id for the wine thread, in this case; I'm using the kernel-mode
APC futex's ntdll_thread_data->*fsync_apc_idx*, the idx gives me that.

a future patch gets rid of the hardcoded values and adds getenv() 

This may be reverted later, but I wanted to see if it was possible. 

 <johnstonljordan AT gmail.com>

--- a/dlls/ntdll/thread.c.orig	2020-06-07 12:38:08.296712170 -0400
+++ b/dlls/ntdll/thread.c	2020-06-07 14:11:25.058387024 -0400
@@ -54,6 +54,39 @@
 #define PTHREAD_STACK_MIN 16384
 #endif
 
+#define FSYNC_RT 1
+
+#if FSYNC_RT
+static int priority;
+
+//int pthread_rt_priority (int policy, int priority)
+//{
+//	/* POSIX requires a spread of at least 32 steps between min..max */
+//	int p_min = 1 (policy); // Linux: 1
+//	int p_max = 99 (policy); // Linux: 99
+//
+//	if (priority > 0) {
+//		priority += p_min;
+//	} else {
+//		priority += p_max;
+//	}
+//	if (priority > p_max) priority = p_max;
+//	if (priority < p_min) priority = p_min;
+//	return priority;
+//}
+
+int pthread_set_rt_priority (pthread_t pthread_id, int policy, int priority)
+{
+	//int policy;
+	
+	struct sched_param param;
+	
+	param.sched_priority = 70;
+
+	return pthread_setschedparam (pthread_id, SCHED_FIFO, &param);
+}
+#endif
+
 struct _KUSER_SHARED_DATA *user_shared_data = NULL;
 
 extern void DECLSPEC_NORETURN __wine_syscall_dispatcher( void );
@@ -586,6 +620,10 @@
     pthread_attr_t pthread_attr;
     struct ntdll_thread_data *thread_data;
     struct startup_info *info;
+    struct sched_param parm;
+    int policy = 0;
+    pthread_attr_setschedpolicy (&pthread_attr, policy);
+    pthread_attr_setschedparam (&pthread_attr, &parm);
     BOOLEAN suspended = !!(flags & THREAD_CREATE_FLAGS_CREATE_SUSPENDED);
     CLIENT_ID *id = NULL;
     HANDLE handle = 0, actctx = 0;
@@ -742,6 +781,24 @@
     if (id) id->UniqueThread = ULongToHandle(tid);
     if (handle_ptr) *handle_ptr = handle;
     else NtClose( handle );
+    
+#if FSYNC_RT
+    // give pthread_create a chance to call start_thread (pthread_info.entry), 
+    // which sets gets the tid via pthread_functions.init_current_teb
+    pthread_t validFsyncIdx = thread_data->fsync_apc_idx;
+    if (validFsyncIdx == 0) {
+        int i;
+        for (i = 0; i < 100; ++i) {
+            validFsyncIdx = thread_data->fsync_apc_idx;
+            if (validFsyncIdx == 0)
+                usleep(3000);
+        }
+    }
+    if (validFsyncIdx != 0)
+    	pthread_set_rt_priority(validFsyncIdx, policy, priority);
+    else
+        WARN("no RT for pthread");
+#endif
 
     return STATUS_SUCCESS;
 
