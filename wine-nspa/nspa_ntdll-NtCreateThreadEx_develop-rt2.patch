 - enable priority inheritance in NtCreateThreadEx() 
 
 - Reduce sync thread priorities to be below RT prioclass threads. this works
   only because of PTHREAD_PRIO_INHERIT being set -- otherwise, priority 
   inversion can/does happen. (it's hilarious too, jack's DSP load goes to 
   almost ZERO, while Kontakt is heavily loaded up. ROFL.).
   
 - move fprintf behind (threadInfo) for unsupported threads.
 
 - fix the white-spacing. That's what i get for accidently using tab or when 
   I cut/paste code, without checking. (face-palm).
   
 I still have a lot of testing to do with this NtCreateThreadEx() develop-rt 
 patchwork, but it's looking VERY promising!
 
 NOTE: squash this later, but i still want a record of these changes.

 Johnstonljordan <AT> gmail <DOT> com

--- a/dlls/ntdll/thread.c.orig	2020-07-10 19:34:48.103454660 -0400
+++ b/dlls/ntdll/thread.c	2020-07-10 19:36:12.734004096 -0400
@@ -98,7 +98,7 @@ int ntdll_set_sync_realtime (pthread_t p
         thread_apc_priority = apc_priority;
     }
 	struct sched_param param;	
-	param.sched_priority = thread_apc_priority -1;
+	param.sched_priority = thread_apc_priority -6;
 
 	return pthread_setschedparam (pthread_id, wine_rt_policy, &param);
 }
@@ -643,6 +643,8 @@ NTSTATUS WINAPI NtCreateThreadEx( HANDLE
     int wine_rt_policy = 0;
     pthread_attr_setschedpolicy (&pthread_attr, wine_rt_policy);
     pthread_attr_setschedparam (&pthread_attr, &parm);
+    pthread_mutexattr_t mattr;
+    pthread_mutexattr_setprotocol(&mattr, PTHREAD_PRIO_INHERIT);
     // glibc get the program name
     extern char *__progname;
     // Add runtime option for checking thread info.
@@ -788,7 +790,8 @@ NTSTATUS WINAPI NtCreateThreadEx( HANDLE
 #if NSPA_RT_SYNC
     thread_data->pthread_id  =  0;
 #endif
-
+    
+    pthread_mutexattr_init ( &mattr );
     pthread_attr_init( &pthread_attr );
     pthread_attr_setstack( &pthread_attr, teb->DeallocationStack,
                          (char *)teb->Tib.StackBase + extra_stack - (char *)teb->DeallocationStack );
@@ -827,38 +830,42 @@ NTSTATUS WINAPI NtCreateThreadEx( HANDLE
     }
     if (validSyncThread != 0) {
         // Fail on / filter out unsupported threads;
-        if (handle == GetCurrentThread() && validSyncThread != thread_data->fsync_apc_idx || 
-            thread_data->esync_apc_fd || thread_data->esync_queue_fd) {
-            fprintf(stderr, "==> PROGRAM NAME: %s <==\n", __progname);
-            fprintf(stderr, "Windows Thread ID: %d\n", GetCurrentThreadId());
-            fprintf(stderr, "Invalid Thread => GetCurrentThread(): %p\n", GetCurrentThread());
+        if (handle == GetCurrentThread() && (validSyncThread != thread_data->fsync_apc_idx || 
+            thread_data->esync_apc_fd || thread_data->esync_queue_fd)) {
+            //  if getenv("NSPA_THREAD_INFO") is set.
+            if (threadInfo) {
+                fprintf(stderr, "==> PROGRAM NAME: %s <==\n", __progname);
+                fprintf(stderr, "Windows Thread ID: %d\n", GetCurrentThreadId());
+                fprintf(stderr, "Invalid Thread => GetCurrentThread(): %p\n", GetCurrentThread());
+            }
             return status;
         }
 
         // set RT for sync threads
-    	ntdll_set_sync_realtime(pthread_self(), wine_rt_policy, priority);
+        pthread_attr_setinheritsched(&pthread_attr, PTHREAD_EXPLICIT_SCHED);
+        ntdll_set_sync_realtime(pthread_self(), wine_rt_policy, priority);
     	
         //  if getenv("NSPA_THREAD_INFO") is set.	
         if (threadInfo) {
-     	    struct sched_param param;
-    	    // if sched_getparam() returns zero, lets go;
-    	    if (sched_getparam( gettid(), &param ) == 0) {
+            struct sched_param param;
+            // if sched_getparam() returns zero, lets go;
+            if (sched_getparam( gettid(), &param ) == 0) {
     	    
-    	    // Get the current thread priority
-    	    sched_getparam(0, &param);
+            // Get the current thread priority
+            sched_getparam(0, &param);
     	    
-    	    // note: policy isn't of interest here. it's FIFO or RR.
-    	    // if 0 is returned - it's SCHED_OTHER.
+            // note: policy isn't of interest here. it's FIFO or RR.
+            // if 0 is returned - it's SCHED_OTHER.
     	    
-    	    // Thread / Process Info.
-           fprintf(stderr, "--------------------------------------------\n");
-           fprintf(stderr, "==> PROGRAM NAME: %s <==\n", __progname);
-           fprintf(stderr, "Pthread Thread Priority: %d\n", param.sched_priority);
-           fprintf(stderr, "Windows Thread ID: %d\n", GetCurrentThreadId());
-    	    fprintf(stderr, "NtCreateThreadEx => pthread_self(): %ld\n", pthread_self());
-    	    fprintf(stderr, "NtCreateThreadEx => glibc gettid(): %d\n", gettid());
-    	    }
-    	}
+            // Thread / Process Info.
+            fprintf(stderr, "--------------------------------------------\n");
+            fprintf(stderr, "==> PROGRAM NAME: %s <==\n", __progname);
+            fprintf(stderr, "Pthread Thread Priority: %d\n", param.sched_priority);
+            fprintf(stderr, "Windows Thread ID: %d\n", GetCurrentThreadId());
+            fprintf(stderr, "NtCreateThreadEx => pthread_self(): %ld\n", pthread_self());
+            fprintf(stderr, "NtCreateThreadEx => glibc gettid(): %d\n", gettid());
+            }
+        }
     }
 #endif
 
