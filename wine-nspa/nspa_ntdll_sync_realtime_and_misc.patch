 - function rename: ntdll_sync_realtime() 
 
 that's a bit more descriptive, as it currently just filters through for APC 
 threads. Furthermore;
 
 - Add support for esync APC threads.
 
 All that seems to be needed is accounting for esync threads. therefore, rename
 validFsyncIdx => validSyncThread, as well.
 
 - Added some Redundancy in scheduler.c, with regards to WINAPI thread 
 priorities that we don't want as RT, even for WINAPI RT priotity class.
 
 - misc cleanups
 
 NOTE: I'll squash this into my RT patch later. more cleanups still.

 johnstonljordan <AT> gmail <DOT> com
 
--- a/dlls/ntdll/thread.c	2020-07-05 19:38:38.928321000 -0400
+++ b/dlls/ntdll/thread.c	2020-07-07 02:17:06.850589844 -0400
@@ -54,11 +54,11 @@ WINE_DEFAULT_DEBUG_CHANNEL(thread);
 #define PTHREAD_STACK_MIN 16384
 #endif
 
-#define FSYNC_RT 1
+#define NSPA_RT_SYNC 1
 
-#if FSYNC_RT
+#if NSPA_RT_SYNC
 
-// We set the APC futex threads RT priority from within Ntdll.
+// We set the synchronization threads' RT priority from within Ntdll.
 // FIFO is hardcoded (regardless of WINE_RT_POLICY)
 
 static int thread_apc_priority = -1;
@@ -79,7 +79,7 @@ static int get_priority( const char *var
 
 static int priority;
 
-int set_pthreads_realtime (pthread_t pthread_id, int wine_rt_policy, int priority)
+int ntdll_sync_realtime (pthread_t pthread_id, int wine_rt_policy, int priority)
 {
     // Get RT policy
     const char *policyStr = getenv("WINE_RT_POLICY");
@@ -784,7 +781,7 @@ NTSTATUS WINAPI NtCreateThreadEx( HANDLE
     pthread_attr_t pthread_attr;
     struct ntdll_thread_data *thread_data;
     struct startup_info *info;
-#if FSYNC_RT
+#if NSPA_RT_SYNC
     // needed for setting SCHED_FIFO for the APC futex threads
     struct sched_param parm;
     int wine_rt_policy = 0;
@@ -925,8 +922,8 @@ NTSTATUS WINAPI NtCreateThreadEx( HANDLE
     thread_data->wait_fd[0]  = -1;
     thread_data->wait_fd[1]  = -1;
     thread_data->start_stack = (char *)teb->Tib.StackBase;
-    thread_data->esync_queue_fd = -1;
-    thread_data->esync_apc_fd = -1;
+    thread_data->esync_queue_fd = 0;
+    thread_data->esync_apc_fd = 0;
     thread_data->fsync_apc_idx = 0;
 #ifdef NSPA_RT_THREADS
     thread_data->pthread_id  =  0;
@@ -951,29 +948,31 @@ NTSTATUS WINAPI NtCreateThreadEx( HANDLE
     if (handle_ptr) *handle_ptr = handle;
     else NtClose( handle );
     
-#if FSYNC_RT
+#if NSPA_RT_SYNC
     // give pthread_create a chance to call start_thread (pthread_info.entry), 
     // which sets gets the tid via pthread_functions.init_current_teb
     // 
-    // catch the APC futex idx. 
-    pthread_t validFsyncIdx = thread_data->fsync_apc_idx;
-    if (validFsyncIdx == 0) {
+    // Catch all the Synchronization Threads 
+    pthread_t validSyncThread = (thread_data->fsync_apc_idx || thread_data->esync_apc_fd ||
+                                 thread_data->esync_queue_fd);
+    if (validSyncThread == 0) {
         int i;
         for (i = 0; i < 100; ++i) {
-            validFsyncIdx = thread_data->fsync_apc_idx;
-            if (validFsyncIdx == 0)
+            validSyncThread = (thread_data->fsync_apc_idx || thread_data->esync_apc_fd ||
+                               thread_data->esync_queue_fd);
+            if (validSyncThread == 0)
                 usleep(100);
         }
     }
-    if (validFsyncIdx != 0) {
+    if (validSyncThread != 0) {
         // this may be redundant, but set PTHREAD_EXPLICIT_SCHED for the
-        // fsync kernel-mode type APC futex threads.
+        // esync/fsync kernel-mode APC threads.
         pthread_attr_setinheritsched(&pthread_attr, PTHREAD_EXPLICIT_SCHED);
         // set realtime threads
-    	set_pthreads_realtime(validFsyncIdx, wine_rt_policy, priority);
+    	ntdll_sync_realtime(validSyncThread, wine_rt_policy, priority);
     	}
     else
-        WARN("no RT for pthread");
+        WARN("no RT sync for thread\n");
 #endif
 
     return STATUS_SUCCESS;
--- a/server/scheduler.c	2020-07-05 19:38:38.920321000 -0400
+++ b/server/scheduler.c	2020-07-07 01:26:26.312711440 -0400
@@ -67,8 +67,10 @@ static int get_priority( const char *var
 /* initializes the scheduler */
 void init_scheduler( void )
 {
+    // Get RT policy
     const char *policyStr = getenv("WINE_RT_POLICY");
 
+    // Set Priority range
     int min, max, priority;
     min = sched_get_priority_min( SCHED_FIFO );
     max = sched_get_priority_max( SCHED_FIFO );
@@ -118,10 +120,11 @@ void init_scheduler( void )
 /* sets the scheduler priority of a windows thread */
 void set_scheduler_priority( struct thread *thread )
 {
+    // Get RT policy
     const char *policyStr = getenv("WINE_RT_POLICY");
     struct sched_param param;
 
-    // set the RT policy
+    // Set RT policy
     if (policyStr) {
         if (strcmp(policyStr, "RR")==0)
             wine_rt_policy = SCHED_RR;
@@ -142,12 +145,14 @@ void set_scheduler_priority( struct thre
     //
     // SCHED_OTHER threads can also have their priority + niceness set. (eg: 0, -20).
     // some threads will be set this way. (again, see server/thread.c)
-    //
-    // simplify the logic from the STAGING_RT patch. realtime or other, that's it!
     
     memset( &param, 0, sizeof(param) );
-    // Any RT thread that isn't TIME_CRITICAL is set to lower priority and can use RR/FF RT Policies.
-    if ((thread->priority = PROCESS_PRIOCLASS_REALTIME && thread->priority != THREAD_PRIORITY_TIME_CRITICAL ))
+    // Any RT thread that isn't TIME_CRITICAL will be set to lower priority and can use RR/FF RT Policies.
+    //
+    // *note: I'm being explicit about threads I definitely do NOT want to be RT, as well. Although, so far
+    // this has not been an issue that i've even observed.
+    if ((thread->priority = PROCESS_PRIOCLASS_REALTIME) && (thread->priority != THREAD_PRIORITY_TIME_CRITICAL ||
+         THREAD_PRIORITY_NORMAL || THREAD_PRIORITY_BELOW_NORMAL || THREAD_PRIORITY_IDLE ))
     {
         param.sched_priority = thread_base_priority -1;
     }
@@ -171,7 +176,7 @@ void set_scheduler_priority( struct thre
                      thread->id, wine_rt_policy, param.sched_priority );
         return;
     }
-    // we care about the fsync_idx threads, in fact; they are critical (don't mind the pun).
+    // we care about the fsync_idx threads, if they come up.
     if (sched_setscheduler(thread->fsync_idx, wine_rt_policy | SCHED_RESET_ON_FORK, &param) == -1 &&
         sched_setscheduler(thread->fsync_idx, wine_rt_policy, &param) == -1)
     {
--- a/server/thread.c	2020-07-05 19:38:38.924321000 -0400
+++ b/server/thread.c	2020-07-07 01:30:41.083870075 -0400
@@ -746,7 +746,7 @@ static int get_unix_priority( int priori
     min = sched_get_priority_min( SCHED_FIFO );
     max = sched_get_priority_max( SCHED_FIFO );
 
-    // RT priority for threads must be below APC futex and Wineserver.(ref: min, max -4)
+    // RT priority for threads must be below kernel-mode APC, TIME_CRITICAL threads and Wineserver.
     if ((base_priority = get_priority( "WINE_RT_PRIO", min, max )) != -1)
     {
         thread_base_priority = base_priority - 1;
@@ -823,7 +823,7 @@ static int get_unix_priority( int priori
     // I am finding it's actually better to get set all of the threads at the same
     // priority...
     //
-    // priorities can be modified, as the comments show (below). 
+    // priorities can be modified, as shown below. 
     
     case PROCESS_PRIOCLASS_REALTIME:
         switch (priority) {
@@ -858,8 +858,10 @@ int set_thread_priority( struct thread*
 {
     // Get RT policy
     const char *policyStr = getenv("WINE_RT_POLICY");
+    // Set Min, Max Priority 
     int max = THREAD_PRIORITY_HIGHEST;
     int min = THREAD_PRIORITY_LOWEST;
+    // Set Min, Max Priority for WINAPI RT
     if (thread->process->priority == PROCESS_PRIOCLASS_REALTIME)
     {
        min = THREAD_PRIORITY_REALTIME_LOWEST;
@@ -876,7 +878,6 @@ int set_thread_priority( struct thread*
 
     thread->priority = priority;
     if (thread->unix_tid == -1)
-    // catch an fsync_idx.
     if (thread->fsync_idx == -1)
             return 0;
  
