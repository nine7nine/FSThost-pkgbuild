A few fixups/comments for the ntdll_rt_threads.patch, plus wiring up getenv().

I will rebase and squash it in with the ntdll_rt_threads.patch later.

 <johnstonljordan AT gmail.com>

diff -pur a/dlls/ntdll/thread.c b/dlls/ntdll/thread.c
--- a/dlls/ntdll/thread.c	2020-06-14 00:22:49.458572000 -0400
+++ b/dlls/ntdll/thread.c	2020-06-16 17:53:01.989202517 -0400
@@ -57,31 +57,42 @@ WINE_DEFAULT_DEBUG_CHANNEL(thread);
 #define FSYNC_RT 1
 
 #if FSYNC_RT
-static int priority;
 
-//int pthread_rt_priority (int policy, int priority)
-//{
-//	/* POSIX requires a spread of at least 32 steps between min..max */
-//	int p_min = 1 (policy); // Linux: 1
-//	int p_max = 99 (policy); // Linux: 99
-//
-//	if (priority > 0) {
-//		priority += p_min;
-//	} else {
-//		priority += p_max;
-//	}
-//	if (priority > p_max) priority = p_max;
-//	if (priority < p_min) priority = p_min;
-//	return priority;
-//}
+// We set the APC futex RT priority from within Ntdll.
+// below functions setup the SCHED_FIFO priority
+
+static int thread_apc_priority = -1;
+
+/* gets the priority value from an environment variable */
+static int get_priority( const char *variable, int min, int max )
+{
+    const char *env;
+    int val;
+
+    env = getenv( variable );
+    if (!env) return -1;
+
+    val = atoi( env );
+    if (val >= min && val <= max) return val;
+    return -1;
+}
+
+static int priority;
 
 int pthread_set_rt_priority (pthread_t pthread_id, int policy, int priority)
 {
-	//int policy;
-	
-	struct sched_param param;
-	
-	param.sched_priority = 70;
+    int min, max, apc_priority;
+
+    min = sched_get_priority_min( SCHED_FIFO );
+    max = sched_get_priority_max( SCHED_FIFO );
+
+    // use WINESERVER_RT_PRIO for now. change this later. 
+    if ((apc_priority = get_priority( "WINESERVER_RT_PRIO", min, max + 3 )) != -1)
+    {
+        thread_apc_priority = apc_priority;
+    }
+	struct sched_param param;	
+	param.sched_priority = thread_apc_priority;
 
 	return pthread_setschedparam (pthread_id, SCHED_FIFO, &param);
 }
@@ -620,10 +779,13 @@ NTSTATUS WINAPI NtCreateThreadEx( HANDLE
     pthread_attr_t pthread_attr;
     struct ntdll_thread_data *thread_data;
     struct startup_info *info;
+#if FSYNC_RT
+    // needed for setting SCHED_FIFO for the APC futex
     struct sched_param parm;
     int policy = 0;
     pthread_attr_setschedpolicy (&pthread_attr, policy);
     pthread_attr_setschedparam (&pthread_attr, &parm);
+#endif
     BOOLEAN suspended = !!(flags & THREAD_CREATE_FLAGS_CREATE_SUSPENDED);
     CLIENT_ID *id = NULL;
     HANDLE handle = 0, actctx = 0;
@@ -785,6 +949,8 @@ NTSTATUS WINAPI NtCreateThreadEx( HANDLE
 #if FSYNC_RT
     // give pthread_create a chance to call start_thread (pthread_info.entry), 
     // which sets gets the tid via pthread_functions.init_current_teb
+    // 
+    // catch the APC futex idx. 
     pthread_t validFsyncIdx = thread_data->fsync_apc_idx;
     if (validFsyncIdx == 0) {
         int i;
@@ -794,8 +960,12 @@ NTSTATUS WINAPI NtCreateThreadEx( HANDLE
                 usleep(3000);
         }
     }
-    if (validFsyncIdx != 0)
+    if (validFsyncIdx != 0) {
+        // this may be redundant, but set PTHREAD_EXPLICIT_SCHED for the
+        // fsync APC futex.
+        pthread_attr_setinheritsched(&pthread_attr, PTHREAD_EXPLICIT_SCHED);
     	pthread_set_rt_priority(validFsyncIdx, policy, priority);
+    	}
     else
         WARN("no RT for pthread");
 #endif
